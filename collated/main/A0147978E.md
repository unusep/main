# A0147978E
###### /java/seedu/doerList/commons/events/ui/CategorySelectionChangedEvent.java
``` java
package seedu.doerList.commons.events.ui;

import seedu.doerList.commons.events.BaseEvent;
import seedu.doerList.model.category.Category;

/**
 * Indicates a event that selection of category has changed
 */
public class CategorySelectionChangedEvent extends BaseEvent {
    private final Category newSelection;

    public CategorySelectionChangedEvent(Category newSelection){
        this.newSelection = newSelection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public Category getNewSelection() {
        return newSelection;
    }
}
```
###### /java/seedu/doerList/commons/events/ui/JumpToCategoryEvent.java
``` java
package seedu.doerList.commons.events.ui;

import seedu.doerList.commons.events.BaseEvent;
import seedu.doerList.model.category.Category;

/**
 * Indicates a request to jump to a category
 */
public class JumpToCategoryEvent extends BaseEvent {

    public final Category target;

    public JumpToCategoryEvent(Category target) {
        this.target = target;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/doerList/commons/events/ui/JumpToListRequestEvent.java
``` java
package seedu.doerList.commons.events.ui;

import seedu.doerList.commons.events.BaseEvent;

/**
 * Indicates a request to jump to the a task indicated by {@code targetIndex}
 */
public class JumpToListRequestEvent extends BaseEvent {

    public final int targetIndex;

    public JumpToListRequestEvent(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/doerList/commons/events/ui/TaskPanelArrowKeyPressEvent.java
``` java
package seedu.doerList.commons.events.ui;

import seedu.doerList.commons.events.BaseEvent;

/**
 * Represents arrow key pressed in the keyboard
 */
public class TaskPanelArrowKeyPressEvent extends BaseEvent {

    private Direction direction;
    
    public static enum Direction {
        UP,
        DOWN
    };

    public TaskPanelArrowKeyPressEvent(Direction direction){
        this.direction = direction;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public Direction getDirection() {
        return direction;
    }
    
}
```
###### /java/seedu/doerList/commons/events/ui/TaskPanelSelectionChangedEvent.java
``` java
package seedu.doerList.commons.events.ui;

import seedu.doerList.commons.events.BaseEvent;
import seedu.doerList.ui.TaskCard;

/**
 * Represents selection changed in the Task List Panel
 */
public class TaskPanelSelectionChangedEvent extends BaseEvent {

    private final TaskCard selectedCard;

    public TaskPanelSelectionChangedEvent(TaskCard selectedCard){
        this.selectedCard = selectedCard;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public TaskCard getNewSelectedCard() {
        return selectedCard;
    }
    
}
```
###### /java/seedu/doerList/logic/commands/DeleteCommand.java
``` java
package seedu.doerList.logic.commands;

import seedu.doerList.commons.core.Messages;
import seedu.doerList.commons.core.UnmodifiableObservableList;
import seedu.doerList.model.task.ReadOnlyTask;
import seedu.doerList.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.doerList.ui.TaskListPanel;

/**
 * Deletes a task identified using it's displayed index from the doerList.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted task: %1$s";

    public final int targetIndex;

    public DeleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        try {
            ReadOnlyTask target = TaskListPanel.getDisplayedIndexWhenCategorizedByBuildInCategory(targetIndex, lastShownList);
            model.deleteTask(target);
            return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, target));
        } catch (TaskNotFoundException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

    }

}
```
###### /java/seedu/doerList/logic/commands/FindCommand.java
``` java
package seedu.doerList.logic.commands;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doerList.commons.core.EventsCenter;
import seedu.doerList.commons.events.ui.JumpToCategoryEvent;
import seedu.doerList.commons.util.StringUtil;
import seedu.doerList.model.category.BuildInCategoryList;
import seedu.doerList.model.task.ReadOnlyTask;

/**
 * Finds and lists all tasks in doerList whose name or description contains any of the argument keywords.
 * Keyword matching is not case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose names or description contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " study";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredListToShowAll();
        updateCategoryAllPredicate();
        model.updateFilteredTaskList(BuildInCategoryList.ALL.getPredicate());
        EventsCenter.getInstance().post(new JumpToCategoryEvent(BuildInCategoryList.ALL));
        return new CommandResult(getMessageForTaskListShownSummary(BuildInCategoryList.ALL.getTasks().size()));
    }

    private void updateCategoryAllPredicate() {
        BuildInCategoryList.ALL.setToDefaultPredicate();
        BuildInCategoryList.ALL.updatePredicate(generateTaskPredicate(this.keywords));
    }

    /**
     * Generate a predicate to check whether a task's title or description
     * contain the given set of keywords
     * 
     * @param keywords A set of keywords
     * @return
     */
    private Predicate<ReadOnlyTask> generateTaskPredicate(Set<String> keywords) {
        return (ReadOnlyTask task) -> {
            return keywords.stream()
                    .filter(generateStringFilter(task))
                    .findAny().isPresent();
        };
    }
    
    /**
     * Generate a String predicate to check whether a string is contained
     * in the task's title and description
     * 
     * @param task Given task
     * @return
     */
    private Predicate<? super String> generateStringFilter(ReadOnlyTask task) {
        Predicate<? super String> predicate = (keyword -> {
                return StringUtil.containsIgnoreCase(task.getTitle().fullTitle, keyword) ||
                    (task.hasDescription() && StringUtil.containsIgnoreCase(task.getDescription().value, keyword));
            });
        return predicate;
    }

}
```
###### /java/seedu/doerList/logic/commands/HelpCommand.java
``` java
            case UndoCommand.COMMAND_WORD:
                return new CommandResult(UndoCommand.MESSAGE_USAGE);
    
            case TaskdueCommand.COMMAND_WORD:
                return new CommandResult(TaskdueCommand.MESSAGE_USAGE);
                
            case SaveCommand.COMMAND_WORD:
                return new CommandResult(SaveCommand.MESSAGE_USAGE);
    
            case "":
                EventsCenter.getInstance().post(new ShowHelpRequestEvent());
                return new CommandResult(SHOWING_HELP_MESSAGE);
    
            default:
                return new CommandResult(INVALID_HELP_MESSAGE);
        }
    }
}
```
###### /java/seedu/doerList/logic/commands/ListCommand.java
``` java
package seedu.doerList.logic.commands;

import java.util.Optional;

import seedu.doerList.commons.core.EventsCenter;
import seedu.doerList.commons.events.ui.JumpToCategoryEvent;
import seedu.doerList.model.category.BuildInCategoryList;
import seedu.doerList.model.category.Category;

/**
 * Lists all tasks in the doerList to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_SUCCESS = "Listed tasks from category: %1$s";
    public static final String MESSAGE_CATEGORY_NOT_EXISTS = "The category name is not existed";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Lists all tasks in the Do-erlist with or without category. "
            + "Parameters: [CATEGORY] \n"
            + "Example: " + COMMAND_WORD
            + " CS2102";


    public String toSelectCategoryName;

    public ListCommand() {}

    public ListCommand(String categoryName) {
        toSelectCategoryName = categoryName;
    }

    /**
     * Try find category name that equals to keyword
     *
     * @param keyword
     * @return Optional<Category> indicates whether find it or not
     */
    public Optional<Category> findNameInCategory(String keyword) {
        if (keyword == null) {
            return Optional.of(BuildInCategoryList.ALL);
        }
        for(Category c : model.getBuildInCategoryList()) {
            if (c.categoryName.equalsIgnoreCase(keyword)) {
                return Optional.of(c);
            }
        }
        for(Category c : model.getCategoryList()) {
            if (c.categoryName.equalsIgnoreCase(keyword)) {
                return Optional.of(c);
            }
        }
        return Optional.empty();
    }

    @Override
    public CommandResult execute() {
        Category toSelectCategory;
        BuildInCategoryList.resetBuildInCategoryPredicate();
        // find the category
        Optional<Category> fromCategory = findNameInCategory(toSelectCategoryName);
        if (fromCategory.isPresent()) {
            toSelectCategory = fromCategory.get();
        } else {
            return new CommandResult(MESSAGE_CATEGORY_NOT_EXISTS);
        }
        // update the predicate in the model
        model.updateFilteredListToShowAll();
        model.updateFilteredTaskList(toSelectCategory.getPredicate());

        EventsCenter.getInstance().post(new JumpToCategoryEvent(toSelectCategory));
        return new CommandResult(String.format(MESSAGE_SUCCESS, toSelectCategory.categoryName));
    }
}
```
###### /java/seedu/doerList/logic/commands/ViewCommand.java
``` java
package seedu.doerList.logic.commands;

import seedu.doerList.commons.core.EventsCenter;
import seedu.doerList.commons.core.Messages;
import seedu.doerList.commons.core.UnmodifiableObservableList;
import seedu.doerList.commons.events.ui.JumpToListRequestEvent;
import seedu.doerList.model.task.ReadOnlyTask;
import seedu.doerList.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.doerList.ui.TaskListPanel;

/**
 * View a specific task's detailed information
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = "view";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": View a specific task in the Do-erList."
            + "Parameters: [TASK_NUMBER]"
            + "Example: " + COMMAND_WORD
            + " 5";
    
    public static final String MESSAGE_VIEW_TASK_SUCCESS = "Viewing task: %1$s";
    
    public final int targetIndex;
    
    public ViewCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }
    
    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        
        try {
            ReadOnlyTask target = TaskListPanel.getDisplayedIndexWhenCategorizedByBuildInCategory(targetIndex, lastShownList);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex - 1));
            return new CommandResult(String.format(MESSAGE_VIEW_TASK_SUCCESS, target));
        } catch (TaskNotFoundException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

    }
}
```
###### /java/seedu/doerList/logic/Logic.java
``` java
    /** Returns the list of build-in category */
    ObservableList<Category> getBuildInCategoryList();

}
```
###### /java/seedu/doerList/logic/LogicManager.java
``` java
    @Override
    public ObservableList<Category> getBuildInCategoryList() {
        return model.getBuildInCategoryList();
    }

```
###### /java/seedu/doerList/logic/LogicManager.java
``` java
    @Override
    public void setPredicateForTaskList(Predicate<ReadOnlyTask> predicate) {
        model.updateFilteredTaskList(predicate);
    }
}
```
###### /java/seedu/doerList/logic/parser/Parser.java
``` java
    private static final Pattern TASK_DATA_TITLE_FORMAT = Pattern.compile("\\/t(?<title>[^\\/]+)");
    private static final Pattern TASK_DATA_DESCRIPTION_FORMAT = Pattern.compile("\\/d(?<description>[^\\/]+)");
    private static final Pattern TASK_DATA_STARTTIME_FORMAT = Pattern.compile("\\/s(?<startTime>[^\\/]+)");
    private static final Pattern TASK_DATA_ENDTIME_FORMAT = Pattern.compile("\\/e(?<endTime>[^\\/]+)");
    private static final Pattern TASK_DATA_CATEGORIES_FORMAT = Pattern.compile("\\/c(?<categories>[^\\/]+)");
```
###### /java/seedu/doerList/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the category name.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareList(String args) {
        if (args.trim().length() == 0) {
            return new ListCommand();
        } else {
            return new ListCommand(args.trim());
        }
    }

```
###### /java/seedu/doerList/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the select task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareView(String args) {
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewCommand.MESSAGE_USAGE));
        }

        return new ViewCommand(index.get());
    }

    /**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     *   Returns an {@code Optional.empty()} otherwise.
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }
    
```
###### /java/seedu/doerList/logic/parser/TimeFormatter.java
``` java
package seedu.doerList.logic.parser;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class TimeFormatter {

    public static final DateTimeFormatter patternWithYear = DateTimeFormatter.ofPattern("Y-M-d HH:mm");
    public static final DateTimeFormatter patternWithoutYear = DateTimeFormatter.ofPattern("M-d HH:mm");
    public static final DateTimeFormatter patternHourMinute = DateTimeFormatter.ofPattern("HH:mm");

    public String toHumanReadableTime(LocalDateTime time) {
        LocalDateTime now = LocalDateTime.now();
        if (now.getYear() != time.getYear()) { // not the same year
            return time.format(patternWithYear);
        }
        // today
        if (now.getDayOfYear() - time.getDayOfYear() == 0) {
            return "Today " + time.format(patternHourMinute);
        } 
        // tomorrow
        if (now.getDayOfYear() - time.getDayOfYear() == -1) {
            return "Tomorrow " + time.format(patternHourMinute);
        }
        // yesterday
        if (now.getDayOfYear() - time.getDayOfYear() == 1) {
            return "Yesterday " + time.format(patternHourMinute);
        }
        return time.format(patternWithoutYear);
    }
}
```
###### /java/seedu/doerList/model/category/BuildInCategory.java
``` java
package seedu.doerList.model.category;

import java.util.function.Predicate;

import seedu.doerList.commons.exceptions.IllegalValueException;
import seedu.doerList.model.task.ReadOnlyTask;

public class BuildInCategory extends Category {
    
    public static String CATEGORY_FILTERED_BADGE = " (filtered)";
    
    Predicate<ReadOnlyTask> defaultPredicate;
    String defaultCategoryName;
    
    Predicate<ReadOnlyTask> currentPredicate;
    
    public BuildInCategory(String name, Predicate<ReadOnlyTask> thePredicate) throws IllegalValueException {
        super(name);
        defaultPredicate = thePredicate;
        currentPredicate = thePredicate;
        defaultCategoryName = name;
    }
    
    /**
     * Return predicate to filter tasks.
     * 
     * @return predicate(lambda) expression to help filter tasks 
     */
    public Predicate<ReadOnlyTask> getPredicate() {
        if (currentPredicate == null) {
            return super.getPredicate();
        } else {
            return currentPredicate;
        }
    }
    
    /**
     * Reset the buildInCategory to default predicate.
     */
    public void setToDefaultPredicate() {
        this.currentPredicate = this.defaultPredicate;
        this.categoryName = this.defaultCategoryName;
    }
    
    /**
     * Update the predicate of the buildInCategory with given {@code thePredicate}.
     * 
     * @param thePredicate
     */
    public void updatePredicate(Predicate<ReadOnlyTask> thePredicate) {
        this.currentPredicate = thePredicate;
        if (!this.categoryName.contains(CATEGORY_FILTERED_BADGE)) {
            this.categoryName = this.categoryName + CATEGORY_FILTERED_BADGE;
        }
    }
    
    @Override
    public boolean isBuildIn() {
        return true;
    } 
    
    
}
```
###### /java/seedu/doerList/model/category/BuildInCategoryList.java
``` java
package seedu.doerList.model.category;

import java.time.LocalDateTime;
import java.util.Collection;
import java.util.Iterator;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.doerList.commons.core.UnmodifiableObservableList;
import seedu.doerList.commons.util.TimeUtil;
import seedu.doerList.model.task.Task;

/**
 * A list of buildinCategories.
 * 
 * @see BuildInCategory#equals(Object)
 */
public class BuildInCategoryList implements Iterable<Category> {  
    public static final BuildInCategory ALL;
    public static final BuildInCategory TODAY;
    public static final BuildInCategory NEXT;
    public static final BuildInCategory INBOX;
    public static final BuildInCategory COMPLETE;
    public static final BuildInCategory DUE;
       
    // predefined category
    static {
        try {
            ALL = new BuildInCategory("All", (task) -> {return true;});     
            INBOX = new BuildInCategory("Inbox", (task) -> {
                return task.isFloatingTask();
            });
            COMPLETE = new BuildInCategory("Complete", (task) -> {
                return task.getBuildInCategories().contains(BuildInCategoryList.COMPLETE);
            });

            TODAY = new BuildInCategory("Today", (task) -> {                
                LocalDateTime todayBegin = TimeUtil.getStartOfDay(LocalDateTime.now());
                LocalDateTime todayEnd = TimeUtil.getEndOfDay(LocalDateTime.now());    
                if (!INBOX.getPredicate().test(task)) {
                    if (task.hasStartTime() && !task.hasEndTime()) {
                        return task.getStartTime().value.isBefore(todayEnd);
                    } else if (task.hasEndTime() && !task.hasStartTime()) {
                        return task.getEndTime().value.isAfter(todayBegin) &&
                                task.getEndTime().value.isBefore(todayEnd);
                    } else {
                        // interval match
                        if (task.getEndTime().value.isAfter(todayBegin) 
                                && task.getStartTime().value.isBefore(todayEnd)) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                } else {
                    return false;
                }
            });
            NEXT = new BuildInCategory("Next", (task) -> {
                LocalDateTime todayEnd = TimeUtil.getEndOfDay(LocalDateTime.now());  
                if (task.hasStartTime()) {
                    return task.getStartTime().value.isAfter(todayEnd);
                } else if (task.hasEndTime()) {
                    return task.getEndTime().value.isAfter(todayEnd);
                } else {
                    return false;
                }
            });         
            DUE = new BuildInCategory("Overdue", (task) -> {
                LocalDateTime todayBegin = TimeUtil.getStartOfDay(LocalDateTime.now());    
                return !task.getBuildInCategories().contains(BuildInCategoryList.COMPLETE) && 
                        
                        task.hasEndTime() && task.getEndTime().value.isBefore(todayBegin);
            });
        } catch (Exception e) {
            e.printStackTrace();
            // impossible
            throw new RuntimeException("Could not init class.", e);
        }
    }
    
    /**
     * Reset all predefined buildInCategories' predicates.
     */
    public static void resetBuildInCategoryPredicate() {
        ALL.setToDefaultPredicate();
        TODAY.setToDefaultPredicate();
        NEXT.setToDefaultPredicate();
        INBOX.setToDefaultPredicate();
        COMPLETE.setToDefaultPredicate();
        DUE.setToDefaultPredicate();
    }
    
    /**
     * Set the tasks source to the buildInCategories so that it can filter task.
     * 
     * @param observableList
     */
    public static void setTasksSource(ObservableList<Task> observableList) {
        ALL.setFilteredTaskList(observableList);
        TODAY.setFilteredTaskList(observableList);
        NEXT.setFilteredTaskList(observableList);
        INBOX.setFilteredTaskList(observableList);
        COMPLETE.setFilteredTaskList(observableList);
        DUE.setFilteredTaskList(observableList);
    }
    
    private final ObservableList<Category> internalList = FXCollections.observableArrayList();

    public void addAllBuildInCategories() {
        internalList.addAll(ALL, TODAY, NEXT, INBOX, COMPLETE);
    }
       
    /**
     * Constructs empty CategoryList.
     */
    public BuildInCategoryList() {}
      
    public BuildInCategoryList(Collection<Category> stroedList) {
        BuildInCategory[] buildInCategories = {ALL, TODAY, NEXT, INBOX, COMPLETE};
        for(Category c : stroedList) {
            for(BuildInCategory bc : buildInCategories) {
                if (c.categoryName.equals(bc.categoryName)) {
                    internalList.add(bc);
                }
            }
        }
    }
    
    /**
     * Replace the data in current buildInCategories with the data in another buildInCategories.
     * 
     * @param buildInCategories
     */
    public void replaceWith(BuildInCategoryList buildInCategories) {
        this.internalList.clear();
        this.internalList.addAll(buildInCategories.internalList);
    }
    
    /**
     * Add a BuildInCategory to the list.
     * Restriction: only BuildInCategory can be added.
     * 
     * @param category
     */
    public void add(BuildInCategory category) {
        if (!contains(category)) {
            internalList.add(category);
        }
    }
    
    /**
     * Remove a BuildInCategory form list.
     * 
     * @param category
     */
    public void remove(BuildInCategory category) {
        if (contains(category)) {
            internalList.remove(category);
        }
    }

    /**
     * Returns true if the list contains an equivalent Category as the given argument.
     */
    public boolean contains(BuildInCategory toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    @Override
    public Iterator<Category> iterator() {
        return internalList.iterator();
    }
    
    @Override
    public boolean equals(Object o) {
        if (o instanceof BuildInCategoryList) {
            BuildInCategoryList other = (BuildInCategoryList) o;
            return this.internalList.equals(other.getInternalList());
        } else {
            return super.equals(o);
        }
    }

    /**
     * Returns {@code UnmodifiableObservableList} so that no one can modify.
     * 
     * @return
     */
    public UnmodifiableObservableList<Category> getInternalList() {
        return new UnmodifiableObservableList<Category>(internalList);
    }
}
```
###### /java/seedu/doerList/model/category/Category.java
``` java
    public FilteredList<ReadOnlyTask> getTasks() {
        assert filteredList != null;
        return filteredList.filtered(this.getPredicate());
    }
    
```
###### /java/seedu/doerList/model/category/Category.java
``` java
    public FilteredList<ReadOnlyTask> getOverdueTasks() {
        assert filteredList != null;
        return this.getTasks().filtered(BuildInCategoryList.DUE.getPredicate());
    }

```
###### /java/seedu/doerList/model/category/Category.java
``` java
    /**
     * Return predicate of the category to filter tasks
     * @return predicate(lambda) expression to help filter tasks 
     */
    public Predicate<ReadOnlyTask> getPredicate() {
        return (ReadOnlyTask task) -> {
            return task.getCategories().contains(this);
        };
    }
    
```
###### /java/seedu/doerList/model/category/Category.java
``` java
    public boolean isBuildIn() {
        return false;
    }
    

}
```
###### /java/seedu/doerList/model/DoerList.java
``` java
    /** 
     * Add listener to categoryList so that every time the category list get added,
     * the {@code tasks} is added into the category.
     */
    private void addListenerToCategoryList() {
        ListChangeListener<? super Category> listener = (ListChangeListener.Change<? extends Category> c) -> {
            while (c.next()) {
                if (c.wasAdded()) {
                    for(Category addedCategory : c.getAddedSubList()) {
                        addedCategory.setFilteredTaskList(getTasks());
                    }
                }
            }
        };
        categories.getInternalList().addListener(listener);
    }

    public DoerList() {}

    /**
     * Tasks and Categories are copied into this doerList
     */
    public DoerList(ReadOnlyDoerList toBeCopied) {
        this(toBeCopied.getUniqueTaskList(), toBeCopied.getUniqueCategoryList());
    }

    /**
     * Tasks and Categories are copied into this doerList
     */
    public DoerList(UniqueTaskList tasks, UniqueCategoryList categories) {
        resetData(tasks.getInternalList(), categories.getInternalList());
    }

    public static ReadOnlyDoerList getEmptyDoerList() {
        return new DoerList();
    }

//// list overwrite operations

    public ObservableList<Task> getTasks() {
        return tasks.getInternalList();
    }
    
    public ObservableList<Category> getCategories() {
        return categories.getInternalList();
    }
    
```
###### /java/seedu/doerList/model/DoerList.java
``` java
    public ObservableList<Category> getBuildInCategories() {
        return buildInCategories.getInternalList();
    }

    public void setTasks(List<Task> tasks) {
        for(Task t : tasks) {
            syncCategoriesWithMasterList(t);
        }
        this.tasks.getInternalList().setAll(tasks);
    }

    public void setCategories(Collection<Category> categories) {
        this.categories.getInternalList().setAll(categories);
    }

    public void resetData(Collection<? extends ReadOnlyTask> newTasks, Collection<Category> newCategories) {
        setCategories(newCategories.stream().map(Category::new).collect(Collectors.toList())); // the order matter
        setTasks(newTasks.stream().map(Task::new).collect(Collectors.toList())); // set tasks must follow the set setCategories
    }

    public void resetData(ReadOnlyDoerList newData) {
        resetData(newData.getTaskList(), newData.getCategoryList());
    }

//// task-level operations

    /**
     * Adds a task to the doerList.
     * Also checks the new task's categories and updates {@link #categories} with any new categories found,
     * and updates the Category objects in the task to point to those in {@link #categories}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task p) throws UniqueTaskList.DuplicateTaskException {
        syncCategoriesWithMasterList(p);
        tasks.add(p);
    }

    /**
     * Ensures that every category in this task:
     *  - exists in the master list {@link #categories}
     *  - points to a Category object in the master list
     */
    private void syncCategoriesWithMasterList(Task task) {
        final UniqueCategoryList taskCategories = task.getCategories();
        categories.mergeFrom(taskCategories);

        // Create map with values = category object references in the master list
        final Map<Category, Category> masterCategoryObjects = new HashMap<>();
        for (Category category : categories) {
            masterCategoryObjects.put(category, category);
        }

        // Rebuild the list of task categories using references from the master list
        final Set<Category> commonCategoryReferences = new HashSet<>();
        for (Category category : taskCategories) {
            commonCategoryReferences.add(masterCategoryObjects.get(category));
        }
        task.setCategories(new UniqueCategoryList(commonCategoryReferences));
    }
    
```
###### /java/seedu/doerList/model/DoerList.java
``` java
    /**
     * Ensure that once the task {@code toRemove} is removed, categories of the task that have
     * no task will be deleted.
     * 
     * @param toRemove
     */
    private void syncCategroiesMaterListAfterRemove(ReadOnlyTask toRemove) {
        for(Category c : toRemove.getCategories()) {
            if (c.getTasks().size() == 0) {
                categories.getInternalList().remove(c);
            } 
        }
    }

```
###### /java/seedu/doerList/model/Model.java
``` java
    /** Returns the build-in category list as an {@code UnmodifiableObservableList<Category>} */
    UnmodifiableObservableList<Category> getBuildInCategoryList();
    
```
###### /java/seedu/doerList/model/Model.java
``` java
    /** Updates the filter of the filtered task list to filter by the given predicate*/
    void updateFilteredTaskList(Predicate<ReadOnlyTask> predicate);

```
###### /java/seedu/doerList/model/Model.java
``` java
    /** Undo the recent addition/edition/deletion of task */
    void undo() throws UndoManager.OperationFailException;
    
```
###### /java/seedu/doerList/model/Model.java
``` java
    /** Redo the recent addition/edition/deletion of task */
    void redo() throws UndoManager.OperationFailException;
}
```
###### /java/seedu/doerList/model/ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<Category> getBuildInCategoryList() {
        return new UnmodifiableObservableList<>(doerList.getBuildInCategories());
    }
    
```
###### /java/seedu/doerList/model/ModelManager.java
``` java
    /**
     * Update the predicate of the {@code filteredTasks}
     */
    @Override
    public void updateFilteredTaskList(Predicate<ReadOnlyTask> predicate) {
        filteredTasks.setPredicate(predicate);
    }

  //=========== Undo redo operation ===============================================================
    
    @Override
    public void undo() throws UndoManager.OperationFailException {
        try {
            Operation op = undoManager.pullUndoStack();
            op.setData(this.doerList);
            op.execute();
            indicateDoerListChanged();
        } catch (Exception e) {
            throw new UndoManager.OperationFailException(e.getMessage());
        }
    }

    @Override
    public void redo() throws UndoManager.OperationFailException {
        Operation op;
        try {
            op = undoManager.pullRedoStack();
            op.setData(this.doerList);
            op.execute();
            indicateDoerListChanged();
        } catch (Exception e) {
            throw new UndoManager.OperationFailException(e.getMessage());
        }
    }

}
```
###### /java/seedu/doerList/model/task/TodoTime.java
``` java
    /**
     * Parse the time to human readable version
     *
     * @return String
     */
    public String toHumanReadableTime() {
        return new TimeFormatter().toHumanReadableTime(value);
    }
```
###### /java/seedu/doerList/model/task/TodoTime.java
``` java
    /**
     * Static method to validate that start time must be before the end time
     *
     * @param task candidate task to validate
     * @throws IllegalValueException
     */
    public static void validateTimeInterval(ReadOnlyTask task) throws IllegalValueException {
        // startTime cannot be smaller than end time
        if (task.hasStartTime() && task.hasEndTime()
                && task.getEndTime().value.isBefore(task.getStartTime().value)) {
            // startTime cannot be smaller than end time
            throw new IllegalValueException(TIME_INTERVAL_CONSTRAIN);
        }
    }
}
```
###### /java/seedu/doerList/model/undo/AddOperation.java
``` java
package seedu.doerList.model.undo;

import seedu.doerList.model.task.Task;
import seedu.doerList.model.task.UniqueTaskList.DuplicateTaskException;

/**
 * Represents a add operation to the doreList
 */
public class AddOperation extends Operation {
    private Task toAdd;
    
    public AddOperation(Task toAdd) {
        this.toAdd = toAdd;
    }
    
    @Override
    public void execute() throws DuplicateTaskException {
        this.doerList.addTask(toAdd);
    }

    /**
     * The inverse of add operation is deletion.
     */
    @Override
    public Operation getInverseOperation() {
        return new DeleteOperation(toAdd);
    }

}
```
###### /java/seedu/doerList/model/undo/DeleteOperation.java
``` java
package seedu.doerList.model.undo;

import seedu.doerList.model.task.Task;
import seedu.doerList.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Represents a delete operation to the doreList
 */
public class DeleteOperation extends Operation {

    private Task toDelete;
    
    public DeleteOperation(Task toDelete) {
        this.toDelete = toDelete;
    }
    
    @Override
    public void execute() throws TaskNotFoundException {
        this.doerList.removeTask(toDelete);
    }

    /**
     * The inverse of delete operation is addition
     */
    @Override
    public Operation getInverseOperation() {
        return new AddOperation(toDelete);
    }

}
```
###### /java/seedu/doerList/model/undo/EditOperation.java
``` java
package seedu.doerList.model.undo;

import seedu.doerList.model.task.Task;
import seedu.doerList.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.doerList.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Represents a delete operation to the doreList
 */
public class EditOperation extends Operation {

    private Task toReplace;
    private Task replaceWith;
    
    public EditOperation(Task toReplace, Task replaceWith) {
        this.toReplace = toReplace;
        this.replaceWith = replaceWith;
    }
    
    @Override
    public void execute() throws DuplicateTaskException, TaskNotFoundException {
        this.doerList.replaceTask(toReplace, replaceWith);
    }

    /**
     * The inverse of edition is to edit back
     */
    @Override
    public Operation getInverseOperation() {
        return new EditOperation(replaceWith, toReplace);
    }
    

}
```
###### /java/seedu/doerList/model/undo/MarkOperation.java
``` java
package seedu.doerList.model.undo;

import seedu.doerList.model.task.ReadOnlyTask;
import seedu.doerList.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.doerList.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Represents a mark operation to the doreList
 */
public class MarkOperation extends Operation {
    private ReadOnlyTask toMark;
    
    public MarkOperation(ReadOnlyTask toMark) {
        this.toMark = toMark;
    }
    
    @Override
    public void execute() throws DuplicateTaskException, TaskNotFoundException {
        this.doerList.markTask(toMark);
    }

    /**
     * The inverse of mark operation is unmark.
     */
    @Override
    public Operation getInverseOperation() {
        return new UnmarkOperation(toMark);
    }

}
```
###### /java/seedu/doerList/model/undo/Operation.java
``` java
package seedu.doerList.model.undo;

import seedu.doerList.model.DoerList;

/**
 * Represents a operation with hidden internal logic and the ability to be executed.
 */
public abstract class Operation {
    protected DoerList doerList;

    /**
     * Executes the operation against the doerList
     */
    public abstract void execute() throws Exception;

    /**
     * Get the inverse operation of current operation
     */
    public abstract Operation getInverseOperation();
    
    
    /**
     * Provides any needed dependencies to the operation.
     * Operations making use of any of these should override this method to gain
     * access to the dependencies.
     */
    public void setData(DoerList doerList) {
        this.doerList = doerList;
    }
}
```
###### /java/seedu/doerList/model/undo/ResetOperation.java
``` java
package seedu.doerList.model.undo;

import seedu.doerList.model.DoerList;
import seedu.doerList.model.ReadOnlyDoerList;

/**
 * Represents a reset operation to the doreList
 */
public class ResetOperation extends Operation {

    private DoerList replaceWith;
    private DoerList toReplace;
    
    public ResetOperation(ReadOnlyDoerList toReplace, DoerList replaceWith) {
        this.toReplace = new DoerList(toReplace);
        this.replaceWith = new DoerList(replaceWith);
    }
    
    @Override
    public void execute() throws Exception {
        this.doerList.resetData(replaceWith);
    }

    /**
     * The inverse of reset operation is reset back
     */
    @Override
    public Operation getInverseOperation() {
        return new ResetOperation(replaceWith, toReplace);
    }

}
```
###### /java/seedu/doerList/model/undo/UndoManager.java
``` java
package seedu.doerList.model.undo;

import java.util.Stack;

import seedu.doerList.model.DoerList;
import seedu.doerList.model.ReadOnlyDoerList;
import seedu.doerList.model.task.ReadOnlyTask;
import seedu.doerList.model.task.Task;

/**
 * Manage the changes to doerList in model component.
 * Keep reverse operation so that can use redo and undo command
 * 
 */
public class UndoManager {
    private Stack<Operation> redoStack = new Stack<Operation>();
    private Stack<Operation> undoStack = new Stack<Operation>();
    
    public static class StackEmptyException extends Exception {
        public StackEmptyException(String s) {
            super(s);
        }
    }
    
    public static class OperationFailException extends Exception {
        public OperationFailException(String s) {
            super(s);
        }
    }
    
    /** ==== Record edition/addition/deletion/reset data to the model(doerList) and generate the reverse operation ====*/
    
    public void recordEdit(ReadOnlyTask toEdit, Task afterEdit) {
        undoStack.push(new EditOperation(afterEdit, new Task(toEdit)));
    }
    
    public void recordAdd(Task toAdd) {
        undoStack.push(new DeleteOperation(toAdd));
    }
    
    public void recordDelete(ReadOnlyTask toDelete) {
        undoStack.push(new AddOperation(new Task(toDelete)));
    }
    
    public void recordReset(DoerList toReplace, ReadOnlyDoerList replaceWith) {
        undoStack.push(new ResetOperation(replaceWith, toReplace));
    }
    
    public void recordMark(ReadOnlyTask toMark) {
        undoStack.push(new UnmarkOperation(toMark));
    }
    
    public void recordUnmark(ReadOnlyTask toUnmark) {
        undoStack.push(new MarkOperation(toUnmark));
    }
    
    /**
     * Pull the most recent redo operation from the redo stack
     * 
     * @return Operation
     * @throws StackEmptyException
     */
    public Operation pullRedoStack() throws StackEmptyException {
        if (redoStack.isEmpty()) {
            throw new StackEmptyException("");
        }
        Operation op = redoStack.pop();
        undoStack.push(op.getInverseOperation()); // as redo operation become undo operation
        return op;
    }
    
    /**
     * Reset the redo stack
     */
    public void resetRedoStack() {
        redoStack.clear();
    }
    
    /**
     * Pull the most recent undo operation in the undo stack
     * 
     * @return Operation
     * @throws StackEmptyException
     */
    public Operation pullUndoStack() throws StackEmptyException {
        if (undoStack.isEmpty()) {
            throw new StackEmptyException("");
        }
        Operation op = undoStack.pop();
        redoStack.push(op.getInverseOperation()); // as undo operation become redo operation
        return op;
    }
}
```
###### /java/seedu/doerList/model/undo/UnmarkOperation.java
``` java
package seedu.doerList.model.undo;

import seedu.doerList.model.task.ReadOnlyTask;
import seedu.doerList.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.doerList.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Represents a unmark operation to the doreList
 */
public class UnmarkOperation extends Operation {
    private ReadOnlyTask toUnmark;
    
    public UnmarkOperation(ReadOnlyTask toUnmark) {
        this.toUnmark = toUnmark;
    }
    
    @Override
    public void execute() throws DuplicateTaskException, TaskNotFoundException {
        this.doerList.unmarkTask(toUnmark);
    }

    /**
     * The inverse of unmark operation is mark.
     */
    @Override
    public Operation getInverseOperation() {
        return new MarkOperation(toUnmark);
    }

}
```
###### /java/seedu/doerList/storage/JavaTimeAdapter.java
``` java
package seedu.doerList.storage;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import javax.xml.bind.annotation.adapters.XmlAdapter;

import seedu.doerList.model.task.TodoTime;

public class JavaTimeAdapter extends XmlAdapter<String, LocalDateTime> {

    @Override
    public LocalDateTime unmarshal(String v) throws Exception {
        return LocalDateTime.parse(v, DateTimeFormatter.ofPattern(TodoTime.TIME_STANDARD_FORMAT));
    }

    @Override
    public String marshal(LocalDateTime v) throws Exception {
        return v.format(DateTimeFormatter.ofPattern(TodoTime.TIME_STANDARD_FORMAT)).toString();
    }

}
```
###### /java/seedu/doerList/ui/CategoryListCard.java
``` java
package seedu.doerList.ui;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import seedu.doerList.model.category.Category;

public class CategoryListCard extends UiPart {
    private static final String FXML = "CategoryListCard.fxml";
    Category category;
    
    @FXML
    private HBox categoryCardPane;
    
    @FXML
    private Label categoryName;
    
    @FXML
    private Label categoryCount;
    
    @FXML
    private StackPane categoryAlertContainer;
    
    @FXML
    private HBox categoryCardSideBar;
    
    @FXML
    private Label categoryAlertCount;
    
    
    public CategoryListCard() {
        super();
    }
    
    public static CategoryListCard load(Category category) {
        CategoryListCard card = new CategoryListCard();
        card.category = category;
        return UiPartLoader.loadUiPart(card);
    }
    
    @FXML
    public void initialize() {
        categoryName.setText(category.categoryName);
        categoryCount.setText(category.getTasks().size() + "");
        displayAlertCount();
    }
    
    /**
     * Display the alert count (red) based on number of tasks due
     */
    private void displayAlertCount() {
        if (category.getOverdueTasks().size() > 0) {
            categoryAlertCount.setText(category.getOverdueTasks().size() + "");
        } else {
            categoryCardSideBar.getChildren().remove(categoryAlertContainer);
        }
    }
    
    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    public HBox getLayout() {
        return categoryCardPane;
    }
    
    /** An Cell represents a category in the listView */
    static class CategoryListViewCell extends ListCell<Category> {

        public CategoryListViewCell() {
        }

        @Override
        protected void updateItem(Category category, boolean empty) {
            super.updateItem(category, empty);

            if (empty || category == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(CategoryListCard.load(category).getLayout());
            }
        }
    }

    @Override
    public void setNode(Node node) {
        // no need
    }
    
}
```
###### /java/seedu/doerList/ui/CategorySideBar.java
``` java
package seedu.doerList.ui;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.doerList.model.category.Category;

public class CategorySideBar extends UiPart {
    private static final String FXML = "CategorySideBar.fxml";
    private AnchorPane placeHolderPane;
    private VBox root;
    
    private CategoryListPanel buildInCategoryList;
    private CategoryListPanel categoryList;
    
    @FXML
    private AnchorPane buildInCategoryListPanelPlaceholder;
    
    @FXML
    private AnchorPane categoryListPanelPlaceholder;
    
    public CategorySideBar() {
        super();
    }
    
    public static CategorySideBar load(Stage primaryStage, AnchorPane placeholder, 
            ObservableList<Category> buildInCategories, ObservableList<Category> categories) {
        CategorySideBar buildInCategoryListPanel = UiPartLoader.loadUiPart(primaryStage, placeholder, new CategorySideBar());
        buildInCategoryListPanel.configure(buildInCategories, categories);
        return buildInCategoryListPanel;
    }
    
    private void configure(ObservableList<Category> buildInCategories, ObservableList<Category> categories) {
        buildInCategoryList = CategoryListPanel.load(primaryStage, getBuildInCategoryListPlaceholder(), buildInCategories);
        categoryList = CategoryListPanel.load(primaryStage, getCategoryListPanelPlaceholder(), categories);
        addToPlaceholder();
    }
    
    private void addToPlaceholder() {
        placeHolderPane.getChildren().add(root);
    }
    
    @Override
    public void setNode(Node node) {
        root = (VBox) node;
    }
    
    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }
    
    public AnchorPane getBuildInCategoryListPlaceholder() {
        return buildInCategoryListPanelPlaceholder;
    }
    
    public AnchorPane getCategoryListPanelPlaceholder() {
        return categoryListPanelPlaceholder;
    }
    
    /**
     * Scroll to the category specific by {@code target}.
     * Both BuildInCategoryList and CategoryList be asked to scroll but the target
     * only exist in one list
     * 
     * @param target
     */
    public void categoryScrollTo(Category target) {
        categoryList.scrollTo(target);
        buildInCategoryList.scrollTo(target);  
    }
    
    /**
     * Set the {@code selection} as active in the list and clear other selection.
     * 
     * @param selection
     */
    public void clearOtherSelectionExcept(Category selection) {
        if (selection.isBuildIn()) {
            categoryList.clearSelection();
        } else {
            buildInCategoryList.clearSelection();
        }
    }

    /**
     * Refresh the displaying of the categories.
     * This is used when the ObservableList has been updated.
     */
    public void refreshCategories() {
        categoryList.redrawListView();
        buildInCategoryList.redrawListView();
    }
    
}
```
###### /java/seedu/doerList/ui/SectionPanel.java
``` java
package seedu.doerList.ui;

import java.util.ArrayList;
import java.util.List;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.doerList.commons.events.ui.TaskPanelSelectionChangedEvent;
import seedu.doerList.commons.util.FxViewUtil;
import seedu.doerList.model.task.ReadOnlyTask;

/**
 * Panel containing the list of sections.
 */
public class SectionPanel extends UiPart {
    private static final String FXML = "SectionPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;
    
    private ArrayList<TaskCard> taskCardControllers;

    @FXML
    private VBox taskListBox;
    @FXML
    private AnchorPane sectionHeaderPlaceholder;

    public SectionPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }
    
    public VBox getLayout() {
        return panel;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }
    
    public void setHeaderTitle(String headerName) {
        TaskListHeader.load(primaryStage, sectionHeaderPlaceholder, headerName);
    }

    public static SectionPanel load(Stage primaryStage, AnchorPane sectionPanelPlaceholder,
                                       List<ReadOnlyTask> taskList, String headerName, int displayIndexStart) {
        SectionPanel sectionPanel =
                UiPartLoader.loadUiPart(primaryStage, sectionPanelPlaceholder, new SectionPanel());
        sectionPanel.configure(taskList, headerName, displayIndexStart);
        return sectionPanel;
    }

    private void configure(List<ReadOnlyTask> taskList, String headerName, int displayIndexStart) {
        setTaskList(taskList, displayIndexStart);
        setHeaderTitle(headerName);
        addToPlaceholder();
    }
    
    /**
     * Set tasklist to the section and create TaskCard for each task.
     * 
     * @param taskList
     * @param displayIndexStart
     */
    private void setTaskList(List<ReadOnlyTask> taskList, int displayIndexStart) {
        taskCardControllers = new ArrayList<TaskCard>();
        int i = displayIndexStart;
        for(ReadOnlyTask task: taskList) {
            AnchorPane container_temp = new AnchorPane();
            taskListBox.getChildren().add(container_temp);
            TaskCard taskCard = TaskCard.load(primaryStage, container_temp, task, i);
            taskCardControllers.add(taskCard);
            FxViewUtil.applyAnchorBoundaryParameters(taskCard.getLayout(), 0.0, 0.0, 0.0, 0.0);
            i++;
        }
    }


    private void addToPlaceholder() {
        placeHolderPane.getChildren().add(panel);
    }

    public ArrayList<TaskCard> getTaskControllers() {
        return taskCardControllers;
    }
    
    /**
     * Find the displayedIndex of a TaskCard.
     * 
     * @param target
     * @return displayedIndex
     */
    public int findSelectionIndex(TaskCard target) {
        int taskCardIndex = -1;
        for(TaskCard tc : this.getTaskControllers()) {
            if (tc == target) {
                taskCardIndex++;
                break;
            }
            taskCardIndex++;
        }
        return taskCardIndex;
    }
    
    /**
     * Select the first Task and set it as active.
     * 
     * @param index the displayedIndex of the task
     */
    public void setFirstTaskToActive(int index) {
        if (index >= 0 && index < this.getTaskControllers().size()) {
            this.getTaskControllers().get(index).setActive();
            raise(new TaskPanelSelectionChangedEvent(this.getTaskControllers().get(index)));
        }
    }

}
```
###### /java/seedu/doerList/ui/TaskCard.java
``` java
package seedu.doerList.ui;

import java.util.logging.Logger;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Paint;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import seedu.doerList.commons.core.LogsCenter;
import seedu.doerList.commons.events.ui.TaskPanelSelectionChangedEvent;
import seedu.doerList.commons.util.FxViewUtil;
import seedu.doerList.model.category.BuildInCategoryList;
import seedu.doerList.model.task.ReadOnlyTask;

/** Card represents a specific task */
public class TaskCard extends UiPart {
    public static final String DESCRIPTION_FIELD_ID = "description";
    public static final String TIME_FIELD_ID = "taskTime";
    public static final String CATEGORY_FIELD_ID = "taskCategory";
    public static final String ACTIVE_STATUS_BACKGROUND = "-fx-background-color: #deeff5;";
    public static final String INACTIVE_STATUS_BACKGROUD = "-fx-background-color: #e6e6e6;";
    public static final String COMPLETE_STATUS_FONT_COLOR = "#787878";
    
    public static TaskCard selectedTaskController;
    
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "TaskCard.fxml";

    private VBox rootPanel;
    private int displayIndex;
    private TaskCardRecurringBar recurringBar;
    
    @FXML
    private VBox taskPanel;
    @FXML
    private AnchorPane descriptionPanel;
    @FXML
    private Label title;
    @FXML
    private Label index;
    @FXML
    private VBox rightBar; // hold taskCategory Label and taskTime Label
    @FXML
    private Label taskCategory;
    @FXML
    private Label taskTime;
    @FXML
    private AnchorPane recurringBarPlaceholder;

    private ReadOnlyTask task;
    private AnchorPane placeHolderPane;

    public TaskCard(){

    }

    public static TaskCard load(Stage primaryStage, AnchorPane taskCardPlaceholder,
                                    ReadOnlyTask task, int displayIndex){
        TaskCard taskCard =
                UiPartLoader.loadUiPart(primaryStage, taskCardPlaceholder, new TaskCard());
        taskCard.task = task;
        taskCard.configure(displayIndex);
        return taskCard;
    }

    public void configure(int displayIndex) {
        taskPanel.setUserData(this); // store the controller
        displayTask(displayIndex);
        this.displayIndex = displayIndex;
        addToPlaceholder();
    }

    private void displayTask(int displayIndex) {
        title.setText(task.getTitle().fullTitle);
        index.setText(displayIndex + "");
        if (task.getBuildInCategories().contains(BuildInCategoryList.COMPLETE)) {
            title.setTextFill(Paint.valueOf(COMPLETE_STATUS_FONT_COLOR));
            index.setTextFill(Paint.valueOf(COMPLETE_STATUS_FONT_COLOR));
        }
        taskCategory.setText(task.getCategories().toString());
        displayTime();
        displayCategories();
        displayRecurringBar();
    }
    
    /**
     * Display the time of task, if the task is floating task, simply remove the node.
     */
    private void displayTime() {
        if (task.isFloatingTask()) {
            rightBar.getChildren().remove(taskTime);
        } else {
            taskTime.setText(task.getTime());
        }
    }
    
    /**
     * Display the categories of task, if the task has no categories, simply remove the node.
     */
    private void displayCategories() {
        if (task.getCategories().isEmpty()) {
            rightBar.getChildren().remove(taskCategory);
        } else {
            taskCategory.setText(task.getCategories().toString());
        }
    }
    
    private void displayRecurringBar() {
        if (task.hasRecurring()) {
            recurringBar = TaskCardRecurringBar.load(getPrimaryStage(), recurringBarPlaceholder, task.getRecurring());
        }
    }

    private void addToPlaceholder() {       
        placeHolderPane.getChildren().add(rootPanel);
    }

    public VBox getLayout() {
        return rootPanel;
    }
    
    public ReadOnlyTask getTask() {
        return task;
    }

    @Override
    public void setNode(Node node) {
        rootPanel = (VBox)node;
    }
    
    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        placeHolderPane = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    /**
     * Set this TaskCard as being selected.
     */
    public void setActive() {
        // to ensure that there is only one task activated
        if (selectedTaskController != null) {
            selectedTaskController.setInactive();
        }
        // change the background color
        taskPanel.setStyle(ACTIVE_STATUS_BACKGROUND);
        selectedTaskController = this;
        expandDetails();
    }
    
    /**
     * Unselect this TaskCard.
     */
    public void setInactive() {
        // change the background color
        taskPanel.setStyle(INACTIVE_STATUS_BACKGROUD);
        closeDetails();
    }
    
    /**
     * Expend the details of the task in UI.
     */
    private void expandDetails() {
        showDescription();
    }
    
    /**
     * Hide the details of the task in UI.
     */
    private void closeDetails() {
        hideDescription();
    }
    
    /**
     * Show the description of task in UI.
     */
    private void showDescription() {
        if (task.hasDescription()) {
            Text descriptionField = new Text();
            descriptionField.setId(DESCRIPTION_FIELD_ID);
            descriptionField.setText(task.getDescription().toString());
            descriptionPanel.getChildren().add(descriptionField);
            FxViewUtil.applyAnchorBoundaryParameters(descriptionField, 0, 0, 0, 0);
        }
    }
    
    /**
     * Hide the description of task in UI.
     */
    private void hideDescription() {
        descriptionPanel.getChildren().clear();
    }
    
    public int getDisplayIndex() {
        return displayIndex;
    }
    
    public static TaskCard getSeletedTaskCard() {
        return selectedTaskController;
    }
    
    public static void clearSelection() {
        if (selectedTaskController != null) {
            selectedTaskController.setInactive();
        }
        selectedTaskController = null;
    }
    
    
    
    @FXML
    public void handleClickAction(MouseEvent event) {
        logger.fine("Selection in task list panel changed to : '" + event.getSource() + "'");
        raise(new TaskPanelSelectionChangedEvent(this));
    }
      
}
```
###### /java/seedu/doerList/ui/TaskCardRecurringBar.java
``` java
package seedu.doerList.ui;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;
import seedu.doerList.MainApp;
import seedu.doerList.model.task.Recurring;

/** Card represents a specific task recurring bar */
public class TaskCardRecurringBar extends UiPart {
    public static final String LOOP_ICON_NAME = "/images/loop_icon.png";
    public static final String INTERVAL_FIELD_ID = "recurringInterval";
    private static final String FXML = "TaskCardRecurringBar.fxml";
    
    private HBox rootPanel;
    private AnchorPane placeHolderPane;
    
    @FXML
    private Label recurringInterval;
    @FXML
    private ImageView recurringIcon;

    private Recurring recurring;

    public TaskCardRecurringBar(){

    }

    public static TaskCardRecurringBar load(Stage primaryStage, AnchorPane recurringBarPlaceholder, Recurring recurring){
        TaskCardRecurringBar recurringBar =
                UiPartLoader.loadUiPart(primaryStage, recurringBarPlaceholder, new TaskCardRecurringBar());
        recurringBar.recurring = recurring;
        recurringBar.configure();
        return recurringBar;
    }

    public void configure() {
        displayIconAndLabel();
        addToPlaceholder();
    }

    private void displayIconAndLabel() {
        recurringIcon.setImage(getImage(LOOP_ICON_NAME));
        recurringInterval.setText(this.recurring.toHumanReadable());
    }

    private void addToPlaceholder() {       
        placeHolderPane.getChildren().add(rootPanel);
    }

    @Override
    public void setNode(Node node) {
        rootPanel = (HBox)node;
    }
    
    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        placeHolderPane = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    private Image getImage(String imagePath) {
        return new Image(MainApp.class.getResourceAsStream(imagePath));
    }
      
}
```
###### /java/seedu/doerList/ui/TaskListPanel.java
``` java
package seedu.doerList.ui;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import java.time.LocalDateTime;

import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.ScrollPane;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.doerList.commons.events.ui.TaskPanelArrowKeyPressEvent;
import seedu.doerList.commons.events.ui.TaskPanelArrowKeyPressEvent.Direction;
import seedu.doerList.commons.util.FxViewUtil;
import seedu.doerList.commons.util.TimeUtil;
import seedu.doerList.model.category.BuildInCategory;
import seedu.doerList.model.category.BuildInCategoryList;
import seedu.doerList.model.task.ReadOnlyTask;
import seedu.doerList.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Panel containing the list of sections with tasks.
 */
public class TaskListPanel extends UiPart {
    /** Define the criteria to categorized the display tasks */
    public static final BuildInCategory[] categorizedBy = {
            BuildInCategoryList.DUE,
            BuildInCategoryList.TODAY, BuildInCategoryList.NEXT, BuildInCategoryList.INBOX,
            BuildInCategoryList.COMPLETE
    };
    
    private static final String FXML = "TaskListPanel.fxml";
    private ScrollPane panel;
    private AnchorPane placeHolderPane;
    private ObservableList<ReadOnlyTask> allTasks;
    
    private ArrayList<SectionPanel> sectionPanelControllers;

    @FXML
    private VBox sectionList;
    
    @FXML
    private ScrollPane tasksScrollPane;

    public TaskListPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (ScrollPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static TaskListPanel load(Stage primaryStage, AnchorPane taskListPlaceholder,
                                       ObservableList<ReadOnlyTask> taskList) {
        TaskListPanel taskListPanel =
                UiPartLoader.loadUiPart(primaryStage, taskListPlaceholder, new TaskListPanel());
        taskListPanel.allTasks = taskList;
        taskListPanel.configure();
        return taskListPanel;
    }

    private void configure() {
        displayTasks();
        addToPlaceholder();
        addListener(allTasks);
        tasksScrollPane.setUserData(this); // store the controller
        remapArrowKeysForScrollPane();
    }
    
    private void addListener(ObservableList<ReadOnlyTask> taskList) {
        taskList.addListener((ListChangeListener.Change<? extends ReadOnlyTask> c) -> {
            displayTasks();
        });
    }

    public void displayTasks() {
        // clear selection first
        TaskCard.clearSelection();
        
        Map<BuildInCategory, List<ReadOnlyTask>> categorized_tasks = 
                categorizedByBuildInCategory(allTasks);
        
        // categorized task based on `categorizedBy`
        int displayIndexStart = 1;
        sectionPanelControllers = new ArrayList<SectionPanel>();
        sectionList.getChildren().clear();
        for(BuildInCategory c : categorizedBy) {  
            if (categorized_tasks.get(c) == null) continue;
            // create new sections
            AnchorPane container_temp = new AnchorPane();
            sectionList.getChildren().add(container_temp);
            SectionPanel controller = SectionPanel.load(primaryStage, container_temp, 
                    categorized_tasks.get(c), c.categoryName, displayIndexStart);
            sectionPanelControllers.add(controller);
            
            displayIndexStart += categorized_tasks.get(c).size();
        }
    }

    private void addToPlaceholder() {
        placeHolderPane.getChildren().add(panel);
        FxViewUtil.applyAnchorBoundaryParameters(panel, 0.0, 0.0, 0.0, 0.0);
    }
    
    /**
     * Move the selection of task according to the parameter {@code Direction}.
     * 
     * @param direction
     */
    public void selectionMove(Direction direction) {
        switch(direction) {
            case UP:
                selectionMoveUp();
                break;
            case DOWN:
                selectionMoveDown();
                break;
        }
    }
    
    /**
     * Move down the selection.
     */
    private void selectionMoveDown() {
        if (TaskCard.getSeletedTaskCard() == null) {
            if (sectionPanelControllers.size() > 0) {
                sectionPanelControllers.get(0).setFirstTaskToActive(0);
            }
        } else {
            TaskCard orginalSelection = TaskCard.getSeletedTaskCard();
            int sectionIndex = findSelectionSection(orginalSelection);
            if (sectionIndex != -1) {
                SectionPanel selectedSection = sectionPanelControllers.get(sectionIndex);
                int targetIndex = selectedSection.findSelectionIndex(orginalSelection);
                if (targetIndex == selectedSection.getTaskControllers().size() - 1) {
                    // last item in section
                    if (sectionIndex != sectionPanelControllers.size() - 1) {
                        sectionPanelControllers.get(sectionIndex + 1).setFirstTaskToActive(0); 
                    }
                } else {
                    selectedSection.setFirstTaskToActive(targetIndex + 1);
                }
            }
        }
    }
    
    /**
     * Move up the selection.
     */
    private void selectionMoveUp() {
        if (TaskCard.getSeletedTaskCard() == null) {
            if (sectionPanelControllers.size() > 0) {
                sectionPanelControllers.get(0).setFirstTaskToActive(0);
            }
        } else {
            TaskCard orginalSelection = TaskCard.getSeletedTaskCard();
            int sectionIndex = findSelectionSection(orginalSelection);
            if (sectionIndex != -1) {
                SectionPanel selectedSection = sectionPanelControllers.get(sectionIndex);
                int targetIndex = selectedSection.findSelectionIndex(orginalSelection);
                if (targetIndex == 0) {
                    // first item in section
                    if (sectionIndex != 0) {
                        SectionPanel previousSection = sectionPanelControllers.get(sectionIndex - 1);
                        previousSection.setFirstTaskToActive(previousSection.getTaskControllers().size() - 1); 
                    }
                } else {
                    selectedSection.setFirstTaskToActive(targetIndex - 1);
                }
            }
        }
    }
    
    /**
     * Find the section index that the {@code TaskCard target} belongs to.
     * If the TaskCard doesn't exist in any section, -1 is returned.
     * 
     * @param target
     * @return index of the section
     */
    private int findSelectionSection(TaskCard target) {
        int selectionIndex = -1;
        for(SectionPanel sp: sectionPanelControllers) {
            if (sp.getTaskControllers().contains(target)) {
                selectionIndex++;
                break;
            }
            selectionIndex++;
        }
        return selectionIndex;
    }
    
    /**
     * Find the {@TaskCard} by using the displayedIndex.
     * 
     * @param displayedIndex
     * @return
     */
    private TaskCard findTaskCardByIndex(int displayedIndex) {
        for(SectionPanel s : sectionPanelControllers) {
            for(TaskCard t : s.getTaskControllers()) {
                if (t.getDisplayIndex() == displayedIndex) {
                    return t;
                }
            }
        }
        return null;
    }
    
    /**
     * Map the Arrow Key in keyboard to response the scroll up/down event.
     */
    private void remapArrowKeysForScrollPane() {
        tasksScrollPane.addEventFilter(KeyEvent.ANY, (KeyEvent event) -> {
            event.consume();
            if (event.getEventType() == KeyEvent.KEY_PRESSED) {
                switch (event.getCode()) {
                    case UP:
                        raise(new TaskPanelArrowKeyPressEvent(TaskPanelArrowKeyPressEvent.Direction.UP));
                        break;
                    case DOWN:
                        raise(new TaskPanelArrowKeyPressEvent(TaskPanelArrowKeyPressEvent.Direction.DOWN));
                        break;
                    default:
                        break;
                }
            }
            
        });
    }
    
    /**
     * Scroll to the given {@code targetIndex} and select it.
     * 
     * @param targetIndex
     */
    public void scrollTo(int targetIndex) {
        TaskCard target = findTaskCardByIndex(targetIndex);
        selectionChanged(target);
    }
    
    
    /**
     * Change the current selection of task to {@code newSelectedCard}.
     * 
     * @param newSelectedCard
     */
    public void selectionChanged(TaskCard newSelectedCard) {
        newSelectedCard.setActive();
        ensureTaskVisible(newSelectedCard);
    }
    
    /**
     * Ensure that a {@code TaskCard} is visible in the scroll panel.
     * 
     * @param taskcard
     */
    private void ensureTaskVisible(TaskCard taskcard) {
        double height = tasksScrollPane.getContent().getBoundsInLocal().getHeight();
        double y = taskcard.getLayout().getHeight();
        int sectionIndex = findSelectionSection(taskcard);
        SectionPanel section = sectionPanelControllers.get(sectionIndex);
        int selectionIndex = section.findSelectionIndex(taskcard);
        
        // offset for the first element
        if (sectionIndex == 0 && selectionIndex == 0) {
            y -= taskcard.getLayout().getHeight();
        }
        
        // offset for the second section and so on
        int k = sectionIndex;
        while (k > 0) {
            y += sectionPanelControllers.get(k - 1).getLayout().getHeight();
            k--;
        }
        
        // offset inside the section list
        int i = 0;
        while (!sectionPanelControllers.get(sectionIndex).getTaskControllers().get(i).equals(taskcard)) {
            y += sectionPanelControllers.get(sectionIndex).getTaskControllers().get(i).getLayout().getHeight();
            i++;
        }
        
        // offset for the last element
        if ((sectionIndex == sectionPanelControllers.size() - 1)
                && (selectionIndex == section.getTaskControllers().size() - 1)) {
            y = height;
        }
        
        // scrolling values range from 0 to 1
        tasksScrollPane.setVvalue(y/height);

        // just for usability
        tasksScrollPane.requestFocus();
    }
    
    /**
     * Categorized tasks based on {@code categorizedBy}.
     * 
     * @param tasks not modifiable
     * @return Map contain buildInCategory to List of tasks
     */
    public static Map<BuildInCategory, List<ReadOnlyTask>> categorizedByBuildInCategory(
        ObservableList<ReadOnlyTask> tasks) {
        HashMap<BuildInCategory, List<ReadOnlyTask>> results = new HashMap<BuildInCategory, List<ReadOnlyTask>>();
        for(BuildInCategory c : categorizedBy) {
            List<ReadOnlyTask> filteredTasks = new ArrayList<ReadOnlyTask>(tasks.filtered(c.getPredicate()));
            // remove complete task in other category except COMPLETE
            if (c != BuildInCategoryList.COMPLETE) {
                filteredTasks = filteredTasks.stream().filter((task) -> { 
                    return !BuildInCategoryList.COMPLETE.getPredicate().test(task);
                            }).collect(Collectors.toList());
            }
            if (filteredTasks.size() > 0) {
                // sort the list before put in
                filteredTasks.sort((t1, t2) -> {
                    if (t1.isFloatingTask() && t2.isFloatingTask()) {
                        return t1.getTitle().fullTitle.compareTo(t2.getTitle().fullTitle);
                    } else {
                        LocalDateTime t1_represent = t1.hasEndTime() ? t1.getEndTime().value : 
                            TimeUtil.getEndOfDay(LocalDateTime.now()).plusYears(2000);
                        LocalDateTime t2_represent = t2.hasEndTime() ? t2.getEndTime().value : 
                            TimeUtil.getEndOfDay(LocalDateTime.now()).plusYears(2000);
                        t1_represent = t1.hasStartTime() ? t1.getStartTime().value : t1_represent;
                        t2_represent = t2.hasStartTime() ? t2.getStartTime().value : t2_represent;
                        if (t1_represent.equals(t2_represent)) {
                            return 0;
                        }
                        return t1_represent.isBefore(t2_represent) ? -1 : 1;
                    }
                });
                results.put(c, filteredTasks);
            }
        }
        return results;
    }
    
    /**
     * Get the displayed index when the tasks is categorized by 
     * {@link #categorizedByBuildInCategory(ObservableList)}.
     * 
     * @param index
     * @param tasks
     * @return
     * @throws TaskNotFoundException
     */
    public static ReadOnlyTask getDisplayedIndexWhenCategorizedByBuildInCategory(int index, 
            ObservableList<ReadOnlyTask> tasks) throws TaskNotFoundException {
        Map<BuildInCategory, List<ReadOnlyTask>> results = categorizedByBuildInCategory(tasks);
        int i = 1;
        for(BuildInCategory c : categorizedBy) {
            if (results.get(c) == null) continue;
            for(ReadOnlyTask t : results.get(c)) {
                if (index == i) {
                    return t;
                }
                i++;
            }
        }
        throw new TaskNotFoundException();
    }

}
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleDoerListChangedEvent(DoerListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTaskListPanel().displayTasks(); // redraw the task panel
        mainWindow.getCategorySideBar().refreshCategories(); // to update category count
    }

    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleHelp();
    }
    
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTaskListPanel().scrollTo(event.targetIndex + 1); // index is offset by 1
    }
    
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleTaskPanelArrowKeyPressEvent(TaskPanelArrowKeyPressEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTaskListPanel().selectionMove(event.getDirection()); // move to the task card
    }
    
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleTaskPanelSelectionChangedEvent(TaskPanelSelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTaskListPanel().selectionChanged(event.getNewSelectedCard());
    }
    
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleCategorySelectionChangedEvent(CategorySelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getCategorySideBar().clearOtherSelectionExcept(event.getNewSelection()); // move to the selection
        logic.setPredicateForTaskList(event.getNewSelection().getPredicate()); // set predicate for taskpanel to filter task
    }
    
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleJumpToCategoryEvent(JumpToCategoryEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getCategorySideBar().refreshCategories(); // refresh categories UI
        mainWindow.getCategorySideBar().categoryScrollTo(event.target); // scroll to the category
    }
    
```
###### /resources/view/CategoryListCard.fxml
``` fxml
-->

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.Region?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.shape.Circle?>
<?import javafx.scene.text.Font?>

<HBox id="categoryCardPane" fx:id="categoryCardPane" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
    <children>
          <VBox alignment="CENTER_LEFT" maxHeight="40.0" minHeight="40.0" prefHeight="40.0">
              <padding>
                  <Insets bottom="5" left="15" right="5" top="5" />
              </padding>

              <children>
                  <HBox alignment="CENTER_LEFT" spacing="5">
                      <children>
                           <Label fx:id="categoryName" styleClass="cell_big_label" text="Category Name" />
                      </children>
                  </HBox>

              </children>
          </VBox>
      <Region HBox.hgrow="ALWAYS" />
      <VBox alignment="CENTER_RIGHT" maxHeight="40.0" minHeight="40.0" prefHeight="40.0">
         <children>
            <HBox fx:id="categoryCardSideBar" alignment="CENTER">
               <children>
                  <StackPane fx:id="categoryAlertContainer">
                     <children>
                        <Circle fill="#e4e4e4" radius="12.0" stroke="#ffffff00" strokeType="INSIDE" style="-fx-fill: #ff8080;" />
                        <Label fx:id="categoryAlertCount" text="0" textFill="WHITE">
                           <font>
                              <Font name="System Bold" size="13.0" />
                           </font></Label>
                     </children>
                  </StackPane>
                  <StackPane>
                     <children>
                        <Circle fill="#e4e4e4" radius="14.0" stroke="WHITE" strokeType="INSIDE" />
                        <Label fx:id="categoryCount" text="0" />
                     </children>
                     <HBox.margin>
                        <Insets left="5.0" />
                     </HBox.margin>
                  </StackPane>
               </children>
            </HBox>
         </children>
      </VBox>
    </children>
</HBox>
```
###### /resources/view/CategoryListPanel.fxml
``` fxml
-->

<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.doerList.ui.CategoryListPanel">
    <children>
        <ListView fx:id="categoryListView" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
###### /resources/view/CategorySideBar.fxml
``` fxml
-->

<?import javafx.scene.control.Separator?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.doerList.ui.CategorySideBar">
   <children>
      <AnchorPane fx:id="buildInCategoryListPanelPlaceholder" maxHeight="-Infinity" minHeight="-Infinity" prefHeight="245.0" />
      <Separator />
      <AnchorPane fx:id="categoryListPanelPlaceholder" />
   </children>
</VBox>
```
###### /resources/view/SectionPanel.fxml
``` fxml
-->

<?import javafx.geometry.Insets?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox fx:id="sectionPanel" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.doerList.ui.SectionPanel">
    <children>
      <AnchorPane fx:id="sectionHeaderPlaceholder" />
      <VBox fx:id="taskListBox">
         <VBox.margin>
            <Insets left="10.0" />
         </VBox.margin></VBox>
    </children>
</VBox>
```
###### /resources/view/TaskCard.fxml
``` fxml
-->

<?import javafx.geometry.Insets?>
<?import javafx.scene.Cursor?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.Region?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>

<VBox xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.doerList.ui.TaskCard">
   <children>
      <VBox fx:id="taskPanel" fillWidth="true" onMouseClicked="#handleClickAction" style="-fx-background-color: #e6e6e6;">
         <children>
            <HBox alignment="CENTER">
               <children>
                  <HBox alignment="CENTER_LEFT">
                     <children>
                        <Label fx:id="index" text="1">
                           <font>
                              <Font name="System Bold" size="17.0" />
                           </font>
                           <HBox.margin>
                              <Insets right="4.0" />
                           </HBox.margin>
                        </Label>
                        <VBox alignment="CENTER_LEFT">
                           <children>
                              <Label fx:id="title" minWidth="60.0" text="Task Name">
                                 <font>
                                    <Font size="17.0" />
                                 </font>
                              </Label>
                              <AnchorPane fx:id="recurringBarPlaceholder">
                                 <VBox.margin>
                                    <Insets />
                                 </VBox.margin>
                              </AnchorPane>
                           </children>
                        </VBox>
                     </children>
                  </HBox>
                  <Region HBox.hgrow="ALWAYS" />
                  <VBox fx:id="rightBar" alignment="CENTER_RIGHT">
                     <children>
                        <Label fx:id="taskTime" text="Task Time">
                           <font>
                              <Font size="14.0" />
                           </font>
                        </Label>
                        <Label fx:id="taskCategory" text="[Category]">
                           <font>
                              <Font name="System Italic" size="10.0" />
                           </font>
                        </Label>
                     </children>
                  </VBox>
               </children>
            </HBox>
            <AnchorPane fx:id="descriptionPanel" />
         </children>
         <padding>
            <Insets bottom="8.0" left="6.0" right="6.0" top="8.0" />
         </padding>
         <cursor>
            <Cursor fx:constant="HAND" />
         </cursor>
      </VBox>
   </children>
   <padding>
      <Insets bottom="8.0" left="6.0" right="6.0" top="8.0" />
   </padding>
</VBox>
```
###### /resources/view/TaskCardRecurringBar.fxml
``` fxml
-->

<?import javafx.scene.control.Label?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.HBox?>

<HBox alignment="CENTER" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.doerList.ui.TaskCardRecurringBar">
   <children>
      <ImageView fx:id="recurringIcon" fitHeight="20.0" fitWidth="20.0" pickOnBounds="true" preserveRatio="true" />
      <Label fx:id="recurringInterval" text="Interval" />
   </children>
</HBox>
```
###### /resources/view/TaskListPanel.fxml
``` fxml
-->

<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<ScrollPane fx:id="tasksScrollPane" fitToWidth="true" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.doerList.ui.TaskListPanel">
   <content>
      <AnchorPane>
         <children>
            <VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                <children>
                  <AnchorPane fx:id="headerPlaceholder" />
                  <VBox fx:id="sectionList" />
                </children>
            </VBox>
         </children>
      </AnchorPane>
   </content>
</ScrollPane>
```
