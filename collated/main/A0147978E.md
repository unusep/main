# A0147978E
###### /java/seedu/doerList/commons/events/ui/CategorySelectionChangedEvent.java
``` java
package seedu.doerList.commons.events.ui;

import seedu.doerList.commons.events.BaseEvent;
import seedu.doerList.model.category.Category;

/**
 * Indicates a event that selection of category has changed
 */
public class CategorySelectionChangedEvent extends BaseEvent {
    private final Category newSelection;

    public CategorySelectionChangedEvent(Category newSelection){
        this.newSelection = newSelection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public Category getNewSelection() {
        return newSelection;
    }
}
```
###### /java/seedu/doerList/commons/events/ui/JumpToCategoryEvent.java
``` java
package seedu.doerList.commons.events.ui;

import seedu.doerList.commons.events.BaseEvent;
import seedu.doerList.model.category.Category;

/**
 * Indicates a request to jump to a category
 */
public class JumpToCategoryEvent extends BaseEvent {

    public final Category target;

    public JumpToCategoryEvent(Category target) {
        this.target = target;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/doerList/commons/events/ui/JumpToListRequestEvent.java
``` java
package seedu.doerList.commons.events.ui;

import seedu.doerList.commons.events.BaseEvent;

/**
 * Indicates a request to jump to the a task indicated by {@code targetIndex}
 */
public class JumpToListRequestEvent extends BaseEvent {

    public final int targetIndex;

    public JumpToListRequestEvent(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/doerList/commons/events/ui/TaskPanelArrowKeyPressEvent.java
``` java
package seedu.doerList.commons.events.ui;

import seedu.doerList.commons.events.BaseEvent;

/**
 * Represents arrow key pressed in the keyboard
 */
public class TaskPanelArrowKeyPressEvent extends BaseEvent {

    private Direction direction;
    
    public static enum Direction {
        UP,
        DOWN
    };

    public TaskPanelArrowKeyPressEvent(Direction direction){
        this.direction = direction;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public Direction getDirection() {
        return direction;
    }
    
}
```
###### /java/seedu/doerList/commons/events/ui/TaskPanelSelectionChangedEvent.java
``` java
package seedu.doerList.commons.events.ui;

import seedu.doerList.commons.events.BaseEvent;
import seedu.doerList.ui.TaskCard;

/**
 * Represents selection changed in the Task List Panel
 */
public class TaskPanelSelectionChangedEvent extends BaseEvent {

    private final TaskCard selectedCard;

    public TaskPanelSelectionChangedEvent(TaskCard selectedCard){
        this.selectedCard = selectedCard;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public TaskCard getNewSelectedCard() {
        return selectedCard;
    }
    
}
```
###### /java/seedu/doerList/logic/commands/DeleteCommand.java
``` java
package seedu.doerList.logic.commands;

import seedu.doerList.commons.core.Messages;
import seedu.doerList.commons.core.UnmodifiableObservableList;
import seedu.doerList.model.task.ReadOnlyTask;
import seedu.doerList.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.doerList.ui.TaskListPanel;

/**
 * Deletes a task identified using it's displayed index from the doerList.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted task: %1$s";

    public final int targetIndex;

    public DeleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        try {
            ReadOnlyTask target = TaskListPanel.getDisplayedIndexWhenCategorizedByBuildInCategory(targetIndex, lastShownList);
            model.deleteTask(target);
            return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, target));
        } catch (TaskNotFoundException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

    }

}
```
###### /java/seedu/doerList/logic/commands/FindCommand.java
``` java
package seedu.doerList.logic.commands;

import java.util.Set;

import seedu.doerList.commons.core.EventsCenter;
import seedu.doerList.commons.events.ui.JumpToCategoryEvent;
import seedu.doerList.commons.util.StringUtil;
import seedu.doerList.model.category.BuildInCategoryList;
import seedu.doerList.model.task.ReadOnlyTask;

/**
 * Finds and lists all tasks in doerList whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose names or description contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " study";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredListToShowAll();
        BuildInCategoryList.resetBuildInCategoryPredicate();
        // update the filter for BuildInCategory All
        BuildInCategoryList.ALL.updatePredicate((ReadOnlyTask task) -> {
            return this.keywords.stream()
            .filter(keyword -> {
                return StringUtil.containsIgnoreCase(task.getTitle().fullTitle, keyword) ||
                        (task.hasDescription() && StringUtil.containsIgnoreCase(task.getDescription().value, keyword));
                })
            .findAny()
            .isPresent();
        });
        // display ALL
        EventsCenter.getInstance().post(new JumpToCategoryEvent(BuildInCategoryList.ALL));
        model.updateFilteredTaskList(BuildInCategoryList.ALL.getPredicate());
        return new CommandResult(getMessageForTaskListShownSummary(BuildInCategoryList.ALL.getTasks().size()));
    }

}
```
###### /java/seedu/doerList/logic/commands/ListCommand.java
``` java
package seedu.doerList.logic.commands;

import java.util.Optional;

import seedu.doerList.commons.core.EventsCenter;
import seedu.doerList.commons.events.ui.JumpToCategoryEvent;
import seedu.doerList.model.category.BuildInCategoryList;
import seedu.doerList.model.category.Category;

/**
 * Lists all tasks in the doerList to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_SUCCESS = "Listed tasks from category: %1$s";
    public static final String MESSAGE_CATEGORY_NOT_EXISTS = "The category name is not existed";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Lists all tasks in the Do-erlist with or without category. "
            + "Parameters: [CATEGORY] \n"
            + "Example: " + COMMAND_WORD
            + " CS2102";


    public String toSelectCategoryName;
    
    public ListCommand() {}
    
    public ListCommand(String categoryName) {
        toSelectCategoryName = categoryName;
    }
    
    /**
     * Try find category name that equals to keyword
     * 
     * @param keyword
     * @return Optional<Category> indicates whether find it or not 
     */
    public Optional<Category> findNameInCategory(String keyword) {
        if (keyword == null) {
            return Optional.of(BuildInCategoryList.ALL);
        }
        for(Category c : model.getBuildInCategoryList()) {
            if (c.categoryName.equals(keyword)) {
                return Optional.of(c);
            }
        }
        for(Category c : model.getCategoryList()) {
            if (c.categoryName.equals(keyword)) {
                return Optional.of(c);
            }
        }
        return Optional.empty();
    }
   
    @Override
    public CommandResult execute() {
        Category toSelectCategory;
        BuildInCategoryList.resetBuildInCategoryPredicate();
        // find the category
        Optional<Category> fromCategory = findNameInCategory(toSelectCategoryName);
        if (fromCategory.isPresent()) {
            toSelectCategory = fromCategory.get();
        } else {
            return new CommandResult(MESSAGE_CATEGORY_NOT_EXISTS);
        }
        // update the predicate in the model
        model.updateFilteredListToShowAll();
        model.updateFilteredTaskList(toSelectCategory.getPredicate());
        
        EventsCenter.getInstance().post(new JumpToCategoryEvent(toSelectCategory));
        return new CommandResult(String.format(MESSAGE_SUCCESS, toSelectCategory.categoryName));
    }
}
```
###### /java/seedu/doerList/logic/commands/ViewCommand.java
``` java
package seedu.doerList.logic.commands;

import seedu.doerList.commons.core.EventsCenter;
import seedu.doerList.commons.core.Messages;
import seedu.doerList.commons.core.UnmodifiableObservableList;
import seedu.doerList.commons.events.ui.JumpToListRequestEvent;
import seedu.doerList.model.task.ReadOnlyTask;
import seedu.doerList.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.doerList.ui.TaskListPanel;

/**
 * View a specific task's detailed information
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = "view";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": View a specific task in the Do-erList."
            + "Parameters: [TASK_NUMBER]"
            + "Example: " + COMMAND_WORD
            + " 5";
    
    public static final String MESSAGE_VIEW_TASK_SUCCESS = "Viewing task: %1$s";
    
    public final int targetIndex;
    
    public ViewCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }
    
    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        
        try {
            ReadOnlyTask target = TaskListPanel.getDisplayedIndexWhenCategorizedByBuildInCategory(targetIndex, lastShownList);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex - 1));
            return new CommandResult(String.format(MESSAGE_VIEW_TASK_SUCCESS, target));
        } catch (TaskNotFoundException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

    }
}
```
###### /java/seedu/doerList/logic/Logic.java
``` java
    /** Returns the list of build-in category */
    ObservableList<Category> getBuildInCategoryList();

}
```
###### /java/seedu/doerList/logic/LogicManager.java
``` java
    @Override
    public ObservableList<Category> getBuildInCategoryList() {
        return model.getBuildInCategoryList();
    }

```
###### /java/seedu/doerList/logic/LogicManager.java
``` java
    @Override
    public void setPredicateForTaskList(Predicate<ReadOnlyTask> predicate) {
        model.updateFilteredTaskList(predicate);
    }
}
```
###### /java/seedu/doerList/logic/parser/Parser.java
``` java
    private static final Pattern TASK_DATA_TITLE_FORMAT = Pattern.compile("\\/t(?<title>[^\\/]+)");
    private static final Pattern TASK_DATA_DESCRIPTION_FORMAT = Pattern.compile("\\/d(?<description>[^\\/]+)");
    private static final Pattern TASK_DATA_STARTTIME_FORMAT = Pattern.compile("\\/s(?<startTime>[^\\/]+)");
    private static final Pattern TASK_DATA_ENDTIME_FORMAT = Pattern.compile("\\/e(?<endTime>[^\\/]+)");
    private static final Pattern TASK_DATA_CATEGORIES_FORMAT = Pattern.compile("\\/c(?<categories>[^\\/]+)");

```
###### /java/seedu/doerList/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the category name.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareList(String args) {
        if (args.trim().length() == 0) {
            return new ListCommand();
        } else {
            return new ListCommand(args.trim());
        }
    }

```
###### /java/seedu/doerList/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the select task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareView(String args) {
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewCommand.MESSAGE_USAGE));
        }

        return new ViewCommand(index.get());
    }

```
###### /java/seedu/doerList/model/category/BuildInCategory.java
``` java
package seedu.doerList.model.category;

import java.util.function.Predicate;

import seedu.doerList.commons.exceptions.IllegalValueException;
import seedu.doerList.model.task.ReadOnlyTask;

public class BuildInCategory extends Category {
    
    public static String CATEGORY_FILTERED_BADGE = " (filtered)";
    
    Predicate<ReadOnlyTask> defaultPredicate;
    String defaultCategoryName;
    
    Predicate<ReadOnlyTask> currentPredicate;
    
    public BuildInCategory(String name, Predicate<ReadOnlyTask> thePredicate) throws IllegalValueException {
        super(name);
        defaultPredicate = thePredicate;
        currentPredicate = thePredicate;
        defaultCategoryName = name;
    }
    
    /**
     * Return predicate to filter tasks.
     * 
     * @return predicate(lambda) expression to help filter tasks 
     */
    public Predicate<ReadOnlyTask> getPredicate() {
        if (currentPredicate == null) {
            return super.getPredicate();
        } else {
            return currentPredicate;
        }
    }
    
    /**
     * Reset the buildInCategory to default predicate.
     */
    public void setToDeafultPredicate() {
        this.currentPredicate = this.defaultPredicate;
        this.categoryName = this.defaultCategoryName;
    }
    
    /**
     * Update the predicate of the buildInCategory with given {@code thePredicate}.
     * 
     * @param thePredicate
     */
    public void updatePredicate(Predicate<ReadOnlyTask> thePredicate) {
        this.currentPredicate = thePredicate;
        if (!this.categoryName.contains(CATEGORY_FILTERED_BADGE)) {
            this.categoryName = this.categoryName + CATEGORY_FILTERED_BADGE;
        }
    }
    
    @Override
    public boolean isBuildIn() {
        return true;
    } 
    
    
}
```
###### /java/seedu/doerList/model/category/BuildInCategoryList.java
``` java
package seedu.doerList.model.category;

import java.time.LocalDateTime;
import java.util.Collection;
import java.util.Iterator;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.doerList.commons.core.UnmodifiableObservableList;
import seedu.doerList.commons.util.TimeUtil;
import seedu.doerList.model.task.Task;

/**
 * A list of buildinCategories.
 * 
 * @see BuildInCategory#equals(Object)
 */
public class BuildInCategoryList implements Iterable<Category> {  
    public static final BuildInCategory ALL;
    public static final BuildInCategory TODAY;
    public static final BuildInCategory NEXT;
    public static final BuildInCategory INBOX;
    public static final BuildInCategory COMPLETE;
    public static final BuildInCategory DUE;
       
    // predefined category
    static {
        try {
            ALL = new BuildInCategory("All", (task) -> {return true;});     
            INBOX = new BuildInCategory("Inbox", (task) -> {
                return task.isFloatingTask();
            });
            COMPLETE = new BuildInCategory("Complete", (task) -> {
                return task.getBuildInCategories().contains(BuildInCategoryList.COMPLETE);
            });
            TODAY = new BuildInCategory("Today", (task) -> {                
                LocalDateTime todayBegin = TimeUtil.getStartOfDay(LocalDateTime.now());
                LocalDateTime todayEnd = TimeUtil.getEndOfDay(LocalDateTime.now());    
                if (!INBOX.getPredicate().test(task)) {
                    if (task.hasStartTime() && !task.hasEndTime()) {
                        return task.getStartTime().value.isBefore(todayEnd);
                    } else if (task.hasEndTime() && !task.hasStartTime()) {
                        return task.getEndTime().value.isAfter(todayBegin) &&
                                task.getEndTime().value.isBefore(todayEnd);
                    } else {
                        // interval match
                        if (task.getEndTime().value.isAfter(todayBegin) 
                                && task.getStartTime().value.isBefore(todayEnd)) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                } else {
                    return false;
                }
            });
            NEXT = new BuildInCategory("Next", (task) -> {
                LocalDateTime todayEnd = TimeUtil.getEndOfDay(LocalDateTime.now());  
                if (task.hasStartTime()) {
                    return task.getStartTime().value.isAfter(todayEnd);
                } else if (task.hasEndTime()) {
                    return task.getEndTime().value.isAfter(todayEnd);
                } else {
                    return false;
                }
            });
            DUE = new BuildInCategory("Overdue", (task) -> {
                LocalDateTime todayBegin = TimeUtil.getStartOfDay(LocalDateTime.now());    
                return !task.getBuildInCategories().contains(BuildInCategoryList.COMPLETE) &&
                        task.hasEndTime() && task.getEndTime().value.isBefore(todayBegin);
            });
        } catch (Exception e) {
            e.printStackTrace();
            // impossible
            throw new RuntimeException("Could not init class.", e);
        }
    }
    
    /**
     * Reset all predefined buildInCategories' predicates.
     */
    public static void resetBuildInCategoryPredicate() {
        ALL.setToDeafultPredicate();
        TODAY.setToDeafultPredicate();
        NEXT.setToDeafultPredicate();
        INBOX.setToDeafultPredicate();
        COMPLETE.setToDeafultPredicate();
        DUE.setToDeafultPredicate();
    }
    
    /**
     * Set the tasks source to the buildInCategories so that it can filter task.
     * 
     * @param observableList
     */
    public static void setTasksSource(ObservableList<Task> observableList) {
        ALL.setFilteredTaskList(observableList);
        TODAY.setFilteredTaskList(observableList);
        NEXT.setFilteredTaskList(observableList);
        INBOX.setFilteredTaskList(observableList);
        COMPLETE.setFilteredTaskList(observableList);
        DUE.setFilteredTaskList(observableList);
    }
    
    private final ObservableList<Category> internalList = FXCollections.observableArrayList();

    public void addAllBuildInCategories() {
        internalList.addAll(ALL, TODAY, NEXT, INBOX, COMPLETE);
    }
       
    /**
     * Constructs empty CategoryList.
     */
    public BuildInCategoryList() {}
      
    public BuildInCategoryList(Collection<Category> stroedList) {
        BuildInCategory[] buildInCategories = {ALL, TODAY, NEXT, INBOX, COMPLETE};
        for(Category c : stroedList) {
            for(BuildInCategory bc : buildInCategories) {
                if (c.categoryName.equals(bc.categoryName)) {
                    internalList.add(bc);
                }
            }
        }
    }
    
    /**
     * Replace the data in current buildInCategories with the data in another buildInCategories.
     * 
     * @param buildInCategories
     */
    public void replaceWith(BuildInCategoryList buildInCategories) {
        this.internalList.clear();
        this.internalList.addAll(buildInCategories.internalList);
    }
    
    /**
     * Add a BuildInCategory to the list.
     * Restriction: only BuildInCategory can be added.
     * 
     * @param category
     */
    public void add(BuildInCategory category) {
        if (!contains(category)) {
            internalList.add(category);
        }
    }
    
    /**
     * Remove a BuildInCategory form list.
     * 
     * @param category
     */
    public void remove(BuildInCategory category) {
        if (contains(category)) {
            internalList.remove(category);
        }
    }

    /**
     * Returns true if the list contains an equivalent Category as the given argument.
     */
    public boolean contains(BuildInCategory toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    @Override
    public Iterator<Category> iterator() {
        return internalList.iterator();
    }
    
    @Override
    public boolean equals(Object o) {
        if (o instanceof BuildInCategoryList) {
            BuildInCategoryList other = (BuildInCategoryList) o;
            return this.internalList.equals(other.getInternalList());
        } else {
            return super.equals(o);
        }
    }

    /**
     * Returns {@code UnmodifiableObservableList} so that no one can modify.
     * 
     * @return
     */
    public UnmodifiableObservableList<Category> getInternalList() {
        return new UnmodifiableObservableList<Category>(internalList);
    }
}
```
###### /java/seedu/doerList/model/category/Category.java
``` java
    /**
     * Return predicate of the category to filter tasks
     * @return predicate(lambda) expression to help filter tasks 
     */
    public Predicate<ReadOnlyTask> getPredicate() {
        return (ReadOnlyTask task) -> {
            return task.getCategories().contains(this);
        };
    }
    
```
###### /java/seedu/doerList/model/category/Category.java
``` java
    public boolean isBuildIn() {
        return false;
    }
    

}
```
###### /java/seedu/doerList/model/DoerList.java
``` java
    /**
     * Add listener to categoryList so that every time the category list get added,
     * the {@code tasks} is added into the category.
     */
    private void addListenerToCategoryList() {
        ListChangeListener<? super Category> listener = (ListChangeListener.Change<? extends Category> c) -> {
            while (c.next()) {
                if (c.wasAdded()) {
                    for(Category addedCategory : c.getAddedSubList()) {
                        addedCategory.setFilteredTaskList(getTasks());
                    }
                }
            }
        };
        categories.getInternalList().addListener(listener);
    }

    public DoerList() {}

    /**
     * Tasks and Categories are copied into this doerList
     */
    public DoerList(ReadOnlyDoerList toBeCopied) {
        this(toBeCopied.getUniqueTaskList(), toBeCopied.getUniqueCategoryList());
    }

    /**
     * Tasks and Categories are copied into this doerList
     */
    public DoerList(UniqueTaskList tasks, UniqueCategoryList categories) {
        resetData(tasks.getInternalList(), categories.getInternalList());
    }

    public static ReadOnlyDoerList getEmptyDoerList() {
        return new DoerList();
    }

//// list overwrite operations

    public ObservableList<Task> getTasks() {
        return tasks.getInternalList();
    }
    
    public ObservableList<Category> getCategories() {
        return categories.getInternalList();
    }
    
```
###### /java/seedu/doerList/model/DoerList.java
``` java
    public ObservableList<Category> getBuildInCategories() {
        return buildInCategories.getInternalList();
    }

    public void setTasks(List<Task> tasks) {
        this.tasks.getInternalList().setAll(tasks);
    }

    public void setCategories(Collection<Category> categories) {
        this.categories.getInternalList().setAll(categories);
    }

    public void resetData(Collection<? extends ReadOnlyTask> newTasks, Collection<Category> newCategories) {
        setTasks(newTasks.stream().map(Task::new).collect(Collectors.toList()));
        setCategories(newCategories);
    }

    public void resetData(ReadOnlyDoerList newData) {
        resetData(newData.getTaskList(), newData.getCategoryList());
    }

//// task-level operations

    /**
     * Adds a task to the doerList.
     * Also checks the new task's categories and updates {@link #categories} with any new categories found,
     * and updates the Category objects in the task to point to those in {@link #categories}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task p) throws UniqueTaskList.DuplicateTaskException {
        syncCategoriesWithMasterList(p);
        tasks.add(p);
    }

    /**
     * Ensures that every category in this task:
     *  - exists in the master list {@link #categories}
     *  - points to a Category object in the master list
     */
    private void syncCategoriesWithMasterList(Task task) {
        final UniqueCategoryList taskCategories = task.getCategories();
        categories.mergeFrom(taskCategories);

        // Create map with values = category object references in the master list
        final Map<Category, Category> masterCategoryObjects = new HashMap<>();
        for (Category category : categories) {
            masterCategoryObjects.put(category, category);
        }

        // Rebuild the list of task categories using references from the master list
        final Set<Category> commonCategoryReferences = new HashSet<>();
        for (Category category : taskCategories) {
            commonCategoryReferences.add(masterCategoryObjects.get(category));
        }
        task.setCategories(new UniqueCategoryList(commonCategoryReferences));
    }

    public boolean removeTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.remove(key)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }

    public void replaceTask(ReadOnlyTask prevTask, Task t) throws DuplicateTaskException, TaskNotFoundException {
        tasks.replace(prevTask, t);
        syncCategoriesWithMasterList(t); // if there is exception, this statement will not be executed
    }

```
###### /java/seedu/doerList/model/Model.java
``` java
    /** Returns the build-in category list as an {@code UnmodifiableObservableList<Category>} */
    UnmodifiableObservableList<Category> getBuildInCategoryList();
    
```
###### /java/seedu/doerList/model/Model.java
``` java
    /** Updates the filter of the filtered task list to filter by the given predicate*/
    void updateFilteredTaskList(Predicate<ReadOnlyTask> predicate);

    void replaceTask(ReadOnlyTask toReplace, Task task) throws UniqueTaskList.DuplicateTaskException, TaskNotFoundException;
    
```
###### /java/seedu/doerList/model/ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<Category> getBuildInCategoryList() {
        return new UnmodifiableObservableList<>(doerList.getBuildInCategories());
    }
    
```
###### /java/seedu/doerList/model/ModelManager.java
``` java
    /**
     * Update the predicate of the {@code filteredTasks}
     */
    @Override
    public void updateFilteredTaskList(Predicate<ReadOnlyTask> predicate) {
        filteredTasks.setPredicate(predicate);
    }

}
```
###### /java/seedu/doerList/storage/JavaTimeAdapter.java
``` java
package seedu.doerList.storage;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import javax.xml.bind.annotation.adapters.XmlAdapter;

import seedu.doerList.model.task.TodoTime;

public class JavaTimeAdapter extends XmlAdapter<String, LocalDateTime> {

    @Override
    public LocalDateTime unmarshal(String v) throws Exception {
        return LocalDateTime.parse(v, DateTimeFormatter.ofPattern(TodoTime.TIME_STANDARD_FORMAT));
    }

    @Override
    public String marshal(LocalDateTime v) throws Exception {
        return v.format(DateTimeFormatter.ofPattern(TodoTime.TIME_STANDARD_FORMAT)).toString();
    }

}
```
###### /java/seedu/doerList/ui/CategoryListCard.java
``` java
package seedu.doerList.ui;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.layout.HBox;
import seedu.doerList.model.category.Category;

public class CategoryListCard extends UiPart {
    private static final String FXML = "CategoryListCard.fxml";
    private HBox root;
    Category category;
    
    @FXML
    private HBox categoryCardPane;
    
    @FXML
    private Label categoryName;
    
    @FXML
    private Label categoryCount;
    
    public CategoryListCard() {
        super();
    }
    
    public static CategoryListCard load(Category category) {
        CategoryListCard card = new CategoryListCard();
        card.category = category;
        return UiPartLoader.loadUiPart(card);
    }
    
    @FXML
    public void initialize() {
        categoryName.setText(category.categoryName);
        categoryCount.setText(category.getTasks().size() + "");
    }
       
    @Override
    public void setNode(Node node) {
        root = (HBox) node;
    }
    
    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    public HBox getLayout() {
        return categoryCardPane;
    }
    
    /** An Cell represents a category in the listView */
    static class CategoryListViewCell extends ListCell<Category> {

        public CategoryListViewCell() {
        }

        @Override
        protected void updateItem(Category category, boolean empty) {
            super.updateItem(category, empty);

            if (empty || category == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(CategoryListCard.load(category).getLayout());
            }
        }
    }
    
}
```
###### /java/seedu/doerList/ui/CategorySideBar.java
``` java
package seedu.doerList.ui;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.doerList.model.category.Category;

public class CategorySideBar extends UiPart {
    private static final String FXML = "CategorySideBar.fxml";
    private AnchorPane placeHolderPane;
    private VBox root;
    
    private CategoryListPanel buildInCategoryList;
    private CategoryListPanel categoryList;
    
    @FXML
    private AnchorPane buildInCategoryListPanelPlaceholder;
    
    @FXML
    private AnchorPane categoryListPanelPlaceholder;
    
    public CategorySideBar() {
        super();
    }
    
    public static CategorySideBar load(Stage primaryStage, AnchorPane placeholder, 
            ObservableList<Category> buildInCategories, ObservableList<Category> categories) {
        CategorySideBar buildInCategoryListPanel = UiPartLoader.loadUiPart(primaryStage, placeholder, new CategorySideBar());
        buildInCategoryListPanel.configure(buildInCategories, categories);
        return buildInCategoryListPanel;
    }
    
    private void configure(ObservableList<Category> buildInCategories, ObservableList<Category> categories) {
        buildInCategoryList = CategoryListPanel.load(primaryStage, getBuildInCategoryListPlaceholder(), buildInCategories);
        categoryList = CategoryListPanel.load(primaryStage, getCategoryListPanelPlaceholder(), categories);
        addToPlaceholder();
    }
    
    private void addToPlaceholder() {
        placeHolderPane.getChildren().add(root);
    }
    
    @Override
    public void setNode(Node node) {
        root = (VBox) node;
    }
    
    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }
    
    public AnchorPane getBuildInCategoryListPlaceholder() {
        return buildInCategoryListPanelPlaceholder;
    }
    
    public AnchorPane getCategoryListPanelPlaceholder() {
        return categoryListPanelPlaceholder;
    }
    
    /**
     * Scroll to the category specific by {@code target}.
     * Both BuildInCategoryList and CategoryList be asked to scroll but the target
     * only exist in one list
     * 
     * @param target
     */
    public void categoryScrollTo(Category target) {
        categoryList.scrollTo(target);
        buildInCategoryList.scrollTo(target);  
    }
    
    /**
     * Set the {@code selection} as active in the list and clear other selection.
     * 
     * @param selection
     */
    public void clearOtherSelectionExcept(Category selection) {
        if (selection.isBuildIn()) {
            categoryList.clearSelection();
        } else {
            buildInCategoryList.clearSelection();
        }
    }

    /**
     * Refresh the displaying of the categories.
     * This is used when the ObservableList has been updated.
     */
    public void refreshCategories() {
        categoryList.redrawListView();
        buildInCategoryList.redrawListView();
    }
    
}
```
###### /java/seedu/doerList/ui/SectionPanel.java
``` java
package seedu.doerList.ui;

import java.util.ArrayList;
import java.util.List;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.doerList.commons.events.ui.TaskPanelSelectionChangedEvent;
import seedu.doerList.commons.util.FxViewUtil;
import seedu.doerList.model.task.ReadOnlyTask;

/**
 * Panel containing the list of sections.
 */
public class SectionPanel extends UiPart {
    private static final String FXML = "SectionPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;
    
    private ArrayList<TaskCard> taskCardControllers;

    @FXML
    private VBox taskListBox;
    @FXML
    private AnchorPane sectionHeaderPlaceholder;

    public SectionPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }
    
    public VBox getLayout() {
        return panel;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }
    
    public void setHeaderTitle(String headerName) {
        TaskListHeader.load(primaryStage, sectionHeaderPlaceholder, headerName);
    }

    public static SectionPanel load(Stage primaryStage, AnchorPane sectionPanelPlaceholder,
                                       List<ReadOnlyTask> taskList, String headerName, int displayIndexStart) {
        SectionPanel sectionPanel =
                UiPartLoader.loadUiPart(primaryStage, sectionPanelPlaceholder, new SectionPanel());
        sectionPanel.configure(taskList, headerName, displayIndexStart);
        return sectionPanel;
    }

    private void configure(List<ReadOnlyTask> taskList, String headerName, int displayIndexStart) {
        setTaskList(taskList, displayIndexStart);
        setHeaderTitle(headerName);
        addToPlaceholder();
    }
    
    /**
     * Set tasklist to the section and create TaskCard for each task.
     * 
     * @param taskList
     * @param displayIndexStart
     */
    private void setTaskList(List<ReadOnlyTask> taskList, int displayIndexStart) {
        taskCardControllers = new ArrayList<TaskCard>();
        int i = displayIndexStart;
        for(ReadOnlyTask task: taskList) {
            AnchorPane container_temp = new AnchorPane();
            taskListBox.getChildren().add(container_temp);
            TaskCard taskCard = TaskCard.load(primaryStage, container_temp, task, i);
            taskCardControllers.add(taskCard);
            FxViewUtil.applyAnchorBoundaryParameters(taskCard.getLayout(), 0.0, 0.0, 0.0, 0.0);
            i++;
        }
    }


    private void addToPlaceholder() {
        placeHolderPane.getChildren().add(panel);
    }

    public ArrayList<TaskCard> getTaskControllers() {
        return taskCardControllers;
    }
    
    /**
     * Find the displayedIndex of a TaskCard.
     * 
     * @param target
     * @return displayedIndex
     */
    public int findSelectionIndex(TaskCard target) {
        int taskCardIndex = -1;
        for(TaskCard tc : this.getTaskControllers()) {
            if (tc == target) {
                taskCardIndex++;
                break;
            }
            taskCardIndex++;
        }
        return taskCardIndex;
    }
    
    /**
     * Select the first Task and set it as active.
     * 
     * @param index the displayedIndex of the task
     */
    public void setFirstTaskToActive(int index) {
        if (index >= 0 && index < this.getTaskControllers().size()) {
            this.getTaskControllers().get(index).setActive();
            raise(new TaskPanelSelectionChangedEvent(this.getTaskControllers().get(index)));
        }
    }

}
```
###### /java/seedu/doerList/ui/TaskCard.java
``` java
package seedu.doerList.ui;

import java.util.logging.Logger;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import seedu.doerList.commons.core.LogsCenter;
import seedu.doerList.commons.events.ui.TaskPanelSelectionChangedEvent;
import seedu.doerList.commons.util.FxViewUtil;
import seedu.doerList.model.task.ReadOnlyTask;

/** Card represents a specific task */
public class TaskCard extends UiPart {
    public static final String DESCRIPTION_FIELD_ID = "description";
    public static final String TIME_FIELD_ID = "taskTime";
    public static final String CATEGORY_FIELD_ID = "taskCategory";
    public static final String ACTIVE_STATUS_BACKGROUND = "-fx-background-color: #deeff5;";
    public static final String INACTIVE_STATUS_BACKGROUD = "-fx-background-color: #e6e6e6;";
    
    public static TaskCard selectedTaskController;
    
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "TaskCard.fxml";

    private VBox rootPanel;
    private int displayIndex;
    
    @FXML
    private VBox taskPanel;
    @FXML
    private AnchorPane descriptionPanel;
    @FXML
    private Label title;
    @FXML
    private Label index;
    @FXML
    private VBox rightBar; // hold taskCategory Label and taskTime Label
    @FXML
    private Label taskCategory;
    @FXML
    private Label taskTime;

    private ReadOnlyTask task;
    private AnchorPane placeHolderPane;

    public TaskCard(){

    }

    public static TaskCard load(Stage primaryStage, AnchorPane taskCardPlaceholder,
                                    ReadOnlyTask task, int displayIndex){
        TaskCard taskCard =
                UiPartLoader.loadUiPart(primaryStage, taskCardPlaceholder, new TaskCard());
        taskCard.task = task;
        taskCard.configure(displayIndex);
        return taskCard;
    }

    public void configure(int displayIndex) {
        taskPanel.setUserData(this); // store the controller
        displayTask(displayIndex);
        this.displayIndex = displayIndex;
        addToPlaceholder();
    }

    private void displayTask(int displayIndex) {
        title.setText(task.getTitle().fullTitle);
        index.setText(displayIndex + "");
        taskCategory.setText(task.getCategories().toString());
        displayTime();
        displayCategories();
        // TODO need to parse to human readable time interval
    }
    
    /**
     * Display the time of task, if the task is floating task, simply remove the node.
     */
    private void displayTime() {
        if (task.isFloatingTask()) {
            rightBar.getChildren().remove(taskTime);
        } else {
            taskTime.setText(task.getTime());
        }
    }
    
    /**
     * Display the categories of task, if the task has no categories, simply remove the node.
     */
    private void displayCategories() {
        if (task.getCategories().isEmpty()) {
            rightBar.getChildren().remove(taskCategory);
        } else {
            taskCategory.setText(task.getCategories().toString());
        }
    }

    private void addToPlaceholder() {       
        placeHolderPane.getChildren().add(rootPanel);
    }

    public VBox getLayout() {
        return rootPanel;
    }
    
    public ReadOnlyTask getTask() {
        return task;
    }

    @Override
    public void setNode(Node node) {
        rootPanel = (VBox)node;
    }
    
    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        placeHolderPane = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    /**
     * Set this TaskCard as being selected.
     */
    public void setActive() {
        // to ensure that there is only one task activated
        if (selectedTaskController != null) {
            selectedTaskController.setInactive();
        }
        // change the background color
        taskPanel.setStyle(ACTIVE_STATUS_BACKGROUND);
        selectedTaskController = this;
        expandDetails();
    }
    
    /**
     * Unselect this TaskCard.
     */
    public void setInactive() {
        // change the background color
        taskPanel.setStyle(INACTIVE_STATUS_BACKGROUD);
        closeDetails();
    }
    
    /**
     * Expend the details of the task in UI.
     */
    private void expandDetails() {
        showDescription();
    }
    
    /**
     * Hide the details of the task in UI.
     */
    private void closeDetails() {
        hideDescription();
    }
    
    /**
     * Show the description of task in UI.
     */
    private void showDescription() {
        if (task.hasDescription()) {
            Text descriptionField = new Text();
            descriptionField.setId(DESCRIPTION_FIELD_ID);
            descriptionField.setText(task.getDescription().toString());
            descriptionPanel.getChildren().add(descriptionField);
            FxViewUtil.applyAnchorBoundaryParameters(descriptionField, 0, 0, 0, 0);
        }
    }
    
    /**
     * Hide the description of task in UI.
     */
    private void hideDescription() {
        descriptionPanel.getChildren().clear();
    }
    
    public int getDisplayIndex() {
        return displayIndex;
    }
    
    public static TaskCard getSeletedTaskCard() {
        return selectedTaskController;
    }
    
    public static void clearSelection() {
        if (selectedTaskController != null) {
            selectedTaskController.setInactive();
        }
        selectedTaskController = null;
    }
    
    
    @FXML
    public void handleClickAction(MouseEvent event) {
        logger.fine("Selection in task list panel changed to : '" + event.getSource() + "'");
        raise(new TaskPanelSelectionChangedEvent(this));
    }
      
}
```
###### /java/seedu/doerList/ui/TaskListPanel.java
``` java
package seedu.doerList.ui;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import java.time.LocalDateTime;

import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.ScrollPane;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.doerList.commons.events.ui.TaskPanelArrowKeyPressEvent;
import seedu.doerList.commons.events.ui.TaskPanelArrowKeyPressEvent.Direction;
import seedu.doerList.commons.util.FxViewUtil;
import seedu.doerList.commons.util.TimeUtil;
import seedu.doerList.model.category.BuildInCategory;
import seedu.doerList.model.category.BuildInCategoryList;
import seedu.doerList.model.task.ReadOnlyTask;
import seedu.doerList.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Panel containing the list of sections with tasks.
 */
public class TaskListPanel extends UiPart {
    /** Define the criteria to categorized the display tasks */
    public static final BuildInCategory[] categorizedBy = {
            BuildInCategoryList.DUE,
            BuildInCategoryList.TODAY, BuildInCategoryList.NEXT, BuildInCategoryList.INBOX,
            BuildInCategoryList.COMPLETE
    };
    
    private static final String FXML = "TaskListPanel.fxml";
    private ScrollPane panel;
    private AnchorPane placeHolderPane;
    private ObservableList<ReadOnlyTask> allTasks;
    
    private ArrayList<SectionPanel> sectionPanelControllers;

    @FXML
    private VBox sectionList;
    
    @FXML
    private ScrollPane tasksScrollPane;

    public TaskListPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (ScrollPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static TaskListPanel load(Stage primaryStage, AnchorPane taskListPlaceholder,
                                       ObservableList<ReadOnlyTask> taskList) {
        TaskListPanel taskListPanel =
                UiPartLoader.loadUiPart(primaryStage, taskListPlaceholder, new TaskListPanel());
        taskListPanel.allTasks = taskList;
        taskListPanel.configure();
        return taskListPanel;
    }

    private void configure() {
        displayTasks();
        addToPlaceholder();
        addListener(allTasks);
        tasksScrollPane.setUserData(this); // store the controller
        remapArrowKeysForScrollPane();
    }
    
    private void addListener(ObservableList<ReadOnlyTask> taskList) {
        taskList.addListener((ListChangeListener.Change<? extends ReadOnlyTask> c) -> {
            displayTasks();
        });
    }

    public void displayTasks() {
        // clear selection first
        TaskCard.clearSelection();
        
        Map<BuildInCategory, List<ReadOnlyTask>> categorized_tasks = 
                categorizedByBuildInCategory(allTasks);
        
        // categorized task based on `categorizedBy`
        int displayIndexStart = 1;
        sectionPanelControllers = new ArrayList<SectionPanel>();
        sectionList.getChildren().clear();
        for(BuildInCategory c : categorizedBy) {  
            if (categorized_tasks.get(c) == null) continue;
            // create new sections
            AnchorPane container_temp = new AnchorPane();
            sectionList.getChildren().add(container_temp);
            SectionPanel controller = SectionPanel.load(primaryStage, container_temp, 
                    categorized_tasks.get(c), c.categoryName, displayIndexStart);
            sectionPanelControllers.add(controller);
            
            displayIndexStart += categorized_tasks.get(c).size();
        }
    }

    private void addToPlaceholder() {
        placeHolderPane.getChildren().add(panel);
        FxViewUtil.applyAnchorBoundaryParameters(panel, 0.0, 0.0, 0.0, 0.0);
    }
    
    /**
     * Move the selection of task according to the parameter {@code Direction}.
     * 
     * @param direction
     */
    public void selectionMove(Direction direction) {
        switch(direction) {
            case UP:
                selectionMoveUp();
                break;
            case DOWN:
                selectionMoveDown();
                break;
        }
    }
    
    /**
     * Move down the selection.
     */
    private void selectionMoveDown() {
        if (TaskCard.getSeletedTaskCard() == null) {
            if (sectionPanelControllers.size() > 0) {
                sectionPanelControllers.get(0).setFirstTaskToActive(0);
            }
        } else {
            TaskCard orginalSelection = TaskCard.getSeletedTaskCard();
            int sectionIndex = findSelectionSection(orginalSelection);
            if (sectionIndex != -1) {
                SectionPanel selectedSection = sectionPanelControllers.get(sectionIndex);
                int targetIndex = selectedSection.findSelectionIndex(orginalSelection);
                if (targetIndex == selectedSection.getTaskControllers().size() - 1) {
                    // last item in section
                    if (sectionIndex != sectionPanelControllers.size() - 1) {
                        sectionPanelControllers.get(sectionIndex + 1).setFirstTaskToActive(0); 
                    }
                } else {
                    selectedSection.setFirstTaskToActive(targetIndex + 1);
                }
            }
        }
    }
    
    /**
     * Move up the selection.
     */
    private void selectionMoveUp() {
        if (TaskCard.getSeletedTaskCard() == null) {
            if (sectionPanelControllers.size() > 0) {
                sectionPanelControllers.get(0).setFirstTaskToActive(0);
            }
        } else {
            TaskCard orginalSelection = TaskCard.getSeletedTaskCard();
            int sectionIndex = findSelectionSection(orginalSelection);
            if (sectionIndex != -1) {
                SectionPanel selectedSection = sectionPanelControllers.get(sectionIndex);
                int targetIndex = selectedSection.findSelectionIndex(orginalSelection);
                if (targetIndex == 0) {
                    // first item in section
                    if (sectionIndex != 0) {
                        SectionPanel previousSection = sectionPanelControllers.get(sectionIndex - 1);
                        previousSection.setFirstTaskToActive(previousSection.getTaskControllers().size() - 1); 
                    }
                } else {
                    selectedSection.setFirstTaskToActive(targetIndex - 1);
                }
            }
        }
    }
    
    /**
     * Find the section index that the {@code TaskCard target} belongs to.
     * If the TaskCard doesn't exist in any section, -1 is returned.
     * 
     * @param target
     * @return index of the section
     */
    private int findSelectionSection(TaskCard target) {
        int selectionIndex = -1;
        for(SectionPanel sp: sectionPanelControllers) {
            if (sp.getTaskControllers().contains(target)) {
                selectionIndex++;
                break;
            }
            selectionIndex++;
        }
        return selectionIndex;
    }
    
    /**
     * Find the {@TaskCard} by using the displayedIndex.
     * 
     * @param displayedIndex
     * @return
     */
    private TaskCard findTaskCardByIndex(int displayedIndex) {
        for(SectionPanel s : sectionPanelControllers) {
            for(TaskCard t : s.getTaskControllers()) {
                if (t.getDisplayIndex() == displayedIndex) {
                    return t;
                }
            }
        }
        return null;
    }
    
    /**
     * Map the Arrow Key in keyboard to response the scroll up/down event.
     */
    private void remapArrowKeysForScrollPane() {
        tasksScrollPane.addEventFilter(KeyEvent.ANY, (KeyEvent event) -> {
            event.consume();
            if (event.getEventType() == KeyEvent.KEY_PRESSED) {
                switch (event.getCode()) {
                    case UP:
                        raise(new TaskPanelArrowKeyPressEvent(TaskPanelArrowKeyPressEvent.Direction.UP));
                        break;
                    case DOWN:
                        raise(new TaskPanelArrowKeyPressEvent(TaskPanelArrowKeyPressEvent.Direction.DOWN));
                        break;
                    default:
                        break;
                }
            }
            
        });
    }
    
    /**
     * Scroll to the given {@code targetIndex} and select it.
     * 
     * @param targetIndex
     */
    public void scrollTo(int targetIndex) {
        TaskCard target = findTaskCardByIndex(targetIndex);
        selectionChanged(target);
    }
    
    
    /**
     * Change the current selection of task to {@code newSelectedCard}.
     * 
     * @param newSelectedCard
     */
    public void selectionChanged(TaskCard newSelectedCard) {
        newSelectedCard.setActive();
        ensureTaskVisible(newSelectedCard);
    }
    
    /**
     * Ensure that a {@code TaskCard} is visible in the scroll panel.
     * 
     * @param taskcard
     */
    private void ensureTaskVisible(TaskCard taskcard) {
        double height = tasksScrollPane.getContent().getBoundsInLocal().getHeight();
        double y = taskcard.getLayout().getParent().getBoundsInParent().getMaxY();
        int sectionIndex = findSelectionSection(taskcard);
        SectionPanel section = sectionPanelControllers.get(sectionIndex);
        int selectionIndex = section.findSelectionIndex(taskcard);
        
        // offset for the first element
        if (sectionIndex == 0 && selectionIndex == 0) {
            y -= taskcard.getLayout().getHeight();
        }
        
        // offset for the second section and so on
        int k = sectionIndex;
        while (k > 0) {
            y += sectionPanelControllers.get(k - 1).getLayout().getHeight();
            k--;
        }
        
        // offset inside the section list
        int i = 0;
        while (!sectionPanelControllers.get(sectionIndex).getTaskControllers().get(i).equals(taskcard)) {
            y += sectionPanelControllers.get(sectionIndex).getTaskControllers().get(i).getLayout().getHeight();
            i++;
        }
        
        // offset for the last element
        if ((sectionIndex == sectionPanelControllers.size() - 1)
                && (selectionIndex == section.getTaskControllers().size() - 1)) {
            y = height;
        }
        
        // scrolling values range from 0 to 1
        tasksScrollPane.setVvalue(y/height);

        // just for usability
        tasksScrollPane.requestFocus();
    }
    
    /**
     * Categorized tasks based on {@code categorizedBy}.
     * 
     * @param tasks not modifiable
     * @return Map contain buildInCategory to List of tasks
     */
    public static Map<BuildInCategory, List<ReadOnlyTask>> categorizedByBuildInCategory(
        ObservableList<ReadOnlyTask> tasks) {
        HashMap<BuildInCategory, List<ReadOnlyTask>> results = new HashMap<BuildInCategory, List<ReadOnlyTask>>();
        for(BuildInCategory c : categorizedBy) {
            List<ReadOnlyTask> filteredTasks = new ArrayList<ReadOnlyTask>(tasks.filtered(c.getPredicate()));
            // remove complete task in other category except COMPLETE
            if (c != BuildInCategoryList.COMPLETE) {
                filteredTasks = filteredTasks.stream().filter((task) -> { 
                    return !BuildInCategoryList.COMPLETE.getPredicate().test(task);
                            }).collect(Collectors.toList());
            }
            if (filteredTasks.size() > 0) {
                // sort the list before put in
                filteredTasks.sort((t1, t2) -> {
                    if (t1.isFloatingTask() && t2.isFloatingTask()) {
                        return t1.getTitle().fullTitle.compareTo(t2.getTitle().fullTitle);
                    } else {
                        LocalDateTime t1_represent = t1.hasEndTime() ? t1.getEndTime().value : 
                            TimeUtil.getEndOfDay(LocalDateTime.now()).plusYears(2000);
                        LocalDateTime t2_represent = t2.hasEndTime() ? t2.getEndTime().value : 
                            TimeUtil.getEndOfDay(LocalDateTime.now()).plusYears(2000);
                        t1_represent = t1.hasStartTime() ? t1.getStartTime().value : t1_represent;
                        t2_represent = t2.hasStartTime() ? t2.getStartTime().value : t2_represent;
                        return t1_represent.isBefore(t2_represent) ? -1 : 1;
                    }
                });
                results.put(c, filteredTasks);
            }
        }
        return results;
    }
    
    /**
     * Get the displayed index when the tasks is categorized by 
     * {@link #categorizedByBuildInCategory(ObservableList)}.
     * 
     * @param index
     * @param tasks
     * @return
     * @throws TaskNotFoundException
     */
    public static ReadOnlyTask getDisplayedIndexWhenCategorizedByBuildInCategory(int index, 
            ObservableList<ReadOnlyTask> tasks) throws TaskNotFoundException {
        Map<BuildInCategory, List<ReadOnlyTask>> results = categorizedByBuildInCategory(tasks);
        int i = 1;
        for(BuildInCategory c : categorizedBy) {
            if (results.get(c) == null) continue;
            for(ReadOnlyTask t : results.get(c)) {
                if (index == i) {
                    return t;
                }
                i++;
            }
        }
        throw new TaskNotFoundException();
    }

}
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleDoerListChangedEvent(DoerListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTaskListPanel().displayTasks(); // redraw the task panel
        mainWindow.getCategorySideBar().refreshCategories(); // to update category count
    }

    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.handleHelp();
    }
    
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTaskListPanel().scrollTo(event.targetIndex + 1); // index is offset by 1
    }
    
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleTaskPanelArrowKeyPressEvent(TaskPanelArrowKeyPressEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTaskListPanel().selectionMove(event.getDirection()); // move to the task card
    }
    
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleTaskPanelSelectionChangedEvent(TaskPanelSelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getTaskListPanel().selectionChanged(event.getNewSelectedCard());
    }
    
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleCategorySelectionChangedEvent(CategorySelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getCategorySideBar().clearOtherSelectionExcept(event.getNewSelection()); // move to the selection
        logic.setPredicateForTaskList(event.getNewSelection().getPredicate()); // set predicate for taskpanel to filter task
    }
    
```
###### /java/seedu/doerList/ui/UiManager.java
``` java
    @Subscribe
    private void handleJumpToCategoryEvent(JumpToCategoryEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getCategorySideBar().refreshCategories(); // refresh categories UI
        mainWindow.getCategorySideBar().categoryScrollTo(event.target); // scroll to the category
    }

}
```
###### /resources/view/CategoryListCard.fxml
``` fxml
-->

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.Region?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.shape.Circle?>

<HBox id="categoryCardPane" fx:id="categoryCardPane" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1">
    <children>
          <VBox alignment="CENTER_LEFT" maxHeight="40.0" minHeight="40.0" prefHeight="40.0">
              <padding>
                  <Insets bottom="5" left="15" right="5" top="5" />
              </padding>

              <children>
                  <HBox alignment="CENTER_LEFT" spacing="5">
                      <children>
                           <Label fx:id="categoryName" styleClass="cell_big_label" text="Category Name" />
                      </children>
                  </HBox>

              </children>
          </VBox>
      <Region HBox.hgrow="ALWAYS" />
      <VBox alignment="CENTER_RIGHT" maxHeight="40.0" minHeight="40.0" prefHeight="40.0">
         <children>
            <HBox alignment="CENTER">
               <children>
                  <StackPane>
                     <children>
                        <Circle fill="#e4e4e4" radius="14.0" stroke="WHITE" strokeType="INSIDE" />
                        <Label fx:id="categoryCount" text="0" />
                     </children>
                  </StackPane>
               </children>
            </HBox>
         </children>
      </VBox>
    </children>
</HBox>
```
###### /resources/view/CategoryListPanel.fxml
``` fxml
-->

<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.doerList.ui.CategoryListPanel">
    <children>
        <ListView fx:id="categoryListView" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
###### /resources/view/CategorySideBar.fxml
``` fxml
-->

<?import javafx.scene.control.Separator?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.doerList.ui.CategorySideBar">
   <children>
      <AnchorPane fx:id="buildInCategoryListPanelPlaceholder" maxHeight="-Infinity" minHeight="-Infinity" prefHeight="245.0" />
      <Separator />
      <AnchorPane fx:id="categoryListPanelPlaceholder" />
   </children>
</VBox>
```
###### /resources/view/SectionPanel.fxml
``` fxml
-->

<?import javafx.geometry.Insets?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox fx:id="sectionPanel" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.doerList.ui.SectionPanel">
    <children>
      <AnchorPane fx:id="sectionHeaderPlaceholder" />
      <VBox fx:id="taskListBox">
         <VBox.margin>
            <Insets left="10.0" />
         </VBox.margin></VBox>
    </children>
</VBox>
```
###### /resources/view/TaskCard.fxml
``` fxml
-->

<?import javafx.geometry.Insets?>
<?import javafx.scene.Cursor?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.Region?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>

<VBox xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.doerList.ui.TaskCard">
   <children>
      <VBox fx:id="taskPanel" fillWidth="true" onMouseClicked="#handleClickAction" style="-fx-background-color: #e6e6e6;">
         <children>
            <HBox alignment="CENTER">
               <children>
                  <HBox alignment="CENTER_LEFT">
                     <children>
                        <Label fx:id="index" text="1">
                           <font>
                              <Font name="System Bold" size="17.0" />
                           </font>
                           <HBox.margin>
                              <Insets right="4.0" />
                           </HBox.margin>
                        </Label>
                        <Label fx:id="title" text="Task Name">
                           <font>
                              <Font size="17.0" />
                           </font>
                        </Label>
                     </children>
                  </HBox>
                  <Region HBox.hgrow="ALWAYS" />
                  <VBox fx:id="rightBar" alignment="CENTER_RIGHT">
                     <children>
                        <Label fx:id="taskTime" text="Task Time">
                           <font>
                              <Font size="14.0" />
                           </font>
                        </Label>
                        <Label fx:id="taskCategory" text="[Category]">
                           <font>
                              <Font name="System Italic" size="10.0" />
                           </font>
                        </Label>
                     </children>
                  </VBox>
               </children>
            </HBox>
            <AnchorPane fx:id="descriptionPanel" />
         </children>
         <padding>
            <Insets bottom="8.0" left="6.0" right="6.0" top="8.0" />
         </padding>
         <cursor>
            <Cursor fx:constant="HAND" />
         </cursor>
      </VBox>
   </children>
   <padding>
      <Insets bottom="8.0" left="6.0" right="6.0" top="8.0" />
   </padding>
</VBox>
```
###### /resources/view/TaskListPanel.fxml
``` fxml
-->

<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<ScrollPane fx:id="tasksScrollPane" fitToWidth="true" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.doerList.ui.TaskListPanel">
   <content>
      <AnchorPane>
         <children>
            <VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                <children>
                  <AnchorPane fx:id="headerPlaceholder" />
                  <VBox fx:id="sectionList" />
                </children>
            </VBox>
         </children>
      </AnchorPane>
   </content>
</ScrollPane>
```
